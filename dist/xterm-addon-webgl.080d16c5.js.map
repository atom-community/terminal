{"mappings":"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","sources":["node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/webpack/universalModuleDefinition","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/webpack/bootstrap","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/GlyphRenderer.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/RectangleRenderer.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/RenderModel.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/TypedArray.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/WebglRenderer.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/WebglUtils.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/atlas/CharAtlasCache.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/atlas/CharAtlasUtils.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/atlas/WebglCharAtlas.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/renderLayer/BaseRenderLayer.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/renderLayer/CursorRenderLayer.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/renderLayer/LinkRenderLayer.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/browser/Color.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/browser/Lifecycle.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/browser/renderer/atlas/Constants.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/EventEmitter.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/Lifecycle.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/TypedArrayUtils.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/buffer/AttributeData.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/buffer/CellData.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/buffer/Constants.ts","node_modules/xterm-addon-webgl/lib/webpack:/src/common/input/TextDecoder.ts","node_modules/xterm-addon-webgl/lib/webpack:/WebglAddon/src/WebglAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebglAddon\"] = factory();\n\telse\n\t\troot[\"WebglAddon\"] = factory();\n})(self, function() {\nreturn ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { createProgram, PROJECTION_MATRIX, throwIfFalsy } from './WebglUtils';\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas';\nimport { IWebGL2RenderingContext, IWebGLVertexArrayObject, IRenderModel, IRasterizedGlyph } from './Types';\nimport { COMBINED_CHAR_BIT_MASK, RENDER_MODEL_INDICIES_PER_CELL, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_BG_OFFSET } from './RenderModel';\nimport { fill } from 'common/TypedArrayUtils';\nimport { slice } from './TypedArray';\nimport { NULL_CELL_CODE, WHITESPACE_CELL_CODE, Attributes, FgFlags } from 'common/buffer/Constants';\nimport { Terminal, IBufferLine } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { AttributeData } from 'common/buffer/AttributeData';\n\ninterface IVertices {\n  attributes: Float32Array;\n  /**\n   * These buffers are the ones used to bind to WebGL, the reason there are\n   * multiple is to allow double buffering to work as you cannot modify the\n   * buffer while it's being used by the GPU. Having multiple lets us start\n   * working on the next frame.\n   */\n  attributesBuffers: Float32Array[];\n  selectionAttributes: Float32Array;\n  count: number;\n}\n\nconst enum VertexAttribLocations {\n  UNIT_QUAD = 0,\n  CELL_POSITION = 1,\n  OFFSET = 2,\n  SIZE = 3,\n  TEXCOORD = 4,\n  TEXSIZE = 5\n}\n\nconst vertexShaderSource = `#version 300 es\nlayout (location = ${VertexAttribLocations.UNIT_QUAD}) in vec2 a_unitquad;\nlayout (location = ${VertexAttribLocations.CELL_POSITION}) in vec2 a_cellpos;\nlayout (location = ${VertexAttribLocations.OFFSET}) in vec2 a_offset;\nlayout (location = ${VertexAttribLocations.SIZE}) in vec2 a_size;\nlayout (location = ${VertexAttribLocations.TEXCOORD}) in vec2 a_texcoord;\nlayout (location = ${VertexAttribLocations.TEXSIZE}) in vec2 a_texsize;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec2 v_texcoord;\n\nvoid main() {\n  vec2 zeroToOne = (a_offset / u_resolution) + a_cellpos + (a_unitquad * a_size);\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_texcoord = a_texcoord + a_unitquad * a_texsize;\n}`;\n\nconst fragmentShaderSource = `#version 300 es\nprecision lowp float;\n\nin vec2 v_texcoord;\n\nuniform sampler2D u_texture;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = texture(u_texture, v_texcoord);\n}`;\n\nconst INDICES_PER_CELL = 10;\nconst BYTES_PER_CELL = INDICES_PER_CELL * Float32Array.BYTES_PER_ELEMENT;\nconst CELL_POSITION_INDICES = 2;\n\nexport class GlyphRenderer {\n  private _atlas: WebglCharAtlas | undefined;\n\n  private _program: WebGLProgram;\n  private _vertexArrayObject: IWebGLVertexArrayObject;\n  private _projectionLocation: WebGLUniformLocation;\n  private _resolutionLocation: WebGLUniformLocation;\n  private _textureLocation: WebGLUniformLocation;\n  private _atlasTexture: WebGLTexture;\n  private _attributesBuffer: WebGLBuffer;\n  private _activeBuffer: number = 0;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(0),\n    attributesBuffers: [\n      new Float32Array(0),\n      new Float32Array(0)\n    ],\n    selectionAttributes: new Float32Array(0)\n  };\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions\n  ) {\n    const gl = this._gl;\n    const program = throwIfFalsy(createProgram(gl, vertexShaderSource, fragmentShaderSource));\n    this._program = program;\n\n    // Uniform locations\n    this._projectionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_projection'));\n    this._resolutionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_resolution'));\n    this._textureLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_texture'));\n\n    // Create and set the vertex array object\n    this._vertexArrayObject = gl.createVertexArray();\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Setup a_unitquad, this defines the 4 vertices of a rectangle\n    const unitQuadVertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n    const unitQuadVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadVerticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, unitQuadVertices, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(VertexAttribLocations.UNIT_QUAD);\n    gl.vertexAttribPointer(VertexAttribLocations.UNIT_QUAD, 2, this._gl.FLOAT, false, 0, 0);\n\n    // Setup the unit quad element array buffer, this points to indices in\n    // unitQuadVertuces to allow is to draw 2 triangles from the vertices\n    const unitQuadElementIndices = new Uint8Array([0, 1, 3, 0, 2, 3]);\n    const elementIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndicesBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, unitQuadElementIndices, gl.STATIC_DRAW);\n\n    // Setup attributes\n    this._attributesBuffer = throwIfFalsy(gl.createBuffer());\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.enableVertexAttribArray(VertexAttribLocations.OFFSET);\n    gl.vertexAttribPointer(VertexAttribLocations.OFFSET, 2, gl.FLOAT, false, BYTES_PER_CELL, 0);\n    gl.vertexAttribDivisor(VertexAttribLocations.OFFSET, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.SIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.SIZE, 2, gl.FLOAT, false, BYTES_PER_CELL, 2 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.SIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.TEXCOORD);\n    gl.vertexAttribPointer(VertexAttribLocations.TEXCOORD, 2, gl.FLOAT, false, BYTES_PER_CELL, 4 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.TEXCOORD, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.TEXSIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.TEXSIZE, 2, gl.FLOAT, false, BYTES_PER_CELL, 6 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.TEXSIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.CELL_POSITION);\n    gl.vertexAttribPointer(VertexAttribLocations.CELL_POSITION, 2, gl.FLOAT, false, BYTES_PER_CELL, 8 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.CELL_POSITION, 1);\n\n    // Setup empty texture atlas\n    this._atlasTexture = throwIfFalsy(gl.createTexture());\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n    // Allow drawing of transparent texture\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n\n    // Set viewport\n    this.onResize();\n  }\n\n  public beginFrame(): boolean {\n    return this._atlas ? this._atlas.beginFrame() : true;\n  }\n\n  public updateCell(x: number, y: number, code: number, bg: number, fg: number, chars: string): void {\n    this._updateCell(this._vertices.attributes, x, y, code, bg, fg, chars);\n  }\n\n  private _updateCell(array: Float32Array, x: number, y: number, code: number | undefined, bg: number, fg: number, chars?: string): void {\n    const terminal = this._terminal;\n\n    const i = (y * terminal.cols + x) * INDICES_PER_CELL;\n\n    // Exit early if this is a null/space character\n    if (code === NULL_CELL_CODE || code === WHITESPACE_CELL_CODE || code === undefined/* This is used for the right side of wide chars */) {\n      fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    let rasterizedGlyph: IRasterizedGlyph;\n    if (!this._atlas) {\n      return;\n    }\n    if (chars && chars.length > 1) {\n      rasterizedGlyph = this._atlas.getRasterizedGlyphCombinedChar(chars, bg, fg);\n    } else {\n      rasterizedGlyph = this._atlas.getRasterizedGlyph(code, bg, fg);\n    }\n\n    // Fill empty if no glyph was found\n    if (!rasterizedGlyph) {\n      fill(array, 0, i, i + INDICES_PER_CELL - 1 - CELL_POSITION_INDICES);\n      return;\n    }\n\n    // a_origin\n    array[i    ] = -rasterizedGlyph.offset.x + this._dimensions.scaledCharLeft;\n    array[i + 1] = -rasterizedGlyph.offset.y + this._dimensions.scaledCharTop;\n    // a_size\n    array[i + 2] = rasterizedGlyph.size.x / this._dimensions.scaledCanvasWidth;\n    array[i + 3] = rasterizedGlyph.size.y / this._dimensions.scaledCanvasHeight;\n    // a_texcoord\n    array[i + 4] = rasterizedGlyph.texturePositionClipSpace.x;\n    array[i + 5] = rasterizedGlyph.texturePositionClipSpace.y;\n    // a_texsize\n    array[i + 6] = rasterizedGlyph.sizeClipSpace.x;\n    array[i + 7] = rasterizedGlyph.sizeClipSpace.y;\n    // a_cellpos only changes on resize\n  }\n\n  public updateSelection(model: IRenderModel): void {\n    const terminal = this._terminal;\n\n    this._vertices.selectionAttributes = slice(this._vertices.attributes, 0);\n\n    const bg = (this._colors.selectionOpaque.rgba >>> 8) | Attributes.CM_RGB;\n\n    if (model.selection.columnSelectMode) {\n      const startCol = model.selection.startCol;\n      const width = model.selection.endCol - startCol;\n      const height = model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow + 1;\n      for (let y = model.selection.viewportCappedStartRow; y < model.selection.viewportCappedStartRow + height; y++) {\n        this._updateSelectionRange(startCol, startCol + width, y, model, bg);\n      }\n    } else {\n      // Draw first row\n      const startCol = model.selection.viewportStartRow === model.selection.viewportCappedStartRow ? model.selection.startCol : 0;\n      const startRowEndCol = model.selection.viewportCappedStartRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n      this._updateSelectionRange(startCol, startRowEndCol, model.selection.viewportCappedStartRow, model, bg);\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.selection.viewportCappedEndRow - model.selection.viewportCappedStartRow - 1, 0);\n      for (let y = model.selection.viewportCappedStartRow + 1; y <= model.selection.viewportCappedStartRow + middleRowsCount; y++) {\n        this._updateSelectionRange(0, startRowEndCol, y, model, bg);\n      }\n\n      // Draw final row\n      if (model.selection.viewportCappedStartRow !== model.selection.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.selection.viewportEndRow === model.selection.viewportCappedEndRow ? model.selection.endCol : terminal.cols;\n        this._updateSelectionRange(0, endCol, model.selection.viewportCappedEndRow, model, bg);\n      }\n    }\n  }\n\n  private _updateSelectionRange(startCol: number, endCol: number, y: number, model: IRenderModel, bg: number): void {\n    const terminal = this._terminal;\n    const row = y + terminal.buffer.active.viewportY;\n    let line: IBufferLine | undefined;\n    for (let x = startCol; x < endCol; x++) {\n      const offset = (y * this._terminal.cols + x) * RENDER_MODEL_INDICIES_PER_CELL;\n      const code = model.cells[offset];\n      let fg = model.cells[offset + RENDER_MODEL_FG_OFFSET];\n      if (fg & FgFlags.INVERSE) {\n        const workCell = new AttributeData();\n        workCell.fg = fg;\n        workCell.bg = model.cells[offset + RENDER_MODEL_BG_OFFSET];\n        // Get attributes from fg (excluding inverse) and resolve inverse by pullibng rgb colors\n        // from bg. This is needed since the inverse fg color should be based on the original bg\n        // color, not on the selection color\n        fg = (fg & ~(Attributes.CM_MASK | Attributes.RGB_MASK | FgFlags.INVERSE));\n        switch (workCell.getBgColorMode()) {\n          case Attributes.CM_P16:\n          case Attributes.CM_P256:\n            const c = this._getColorFromAnsiIndex(workCell.getBgColor()).rgba;\n            fg |= (c >> 8) & Attributes.RED_MASK | (c >> 8) & Attributes.GREEN_MASK | (c >> 8) & Attributes.BLUE_MASK;\n          case Attributes.CM_RGB:\n            const arr = AttributeData.toColorRGB(workCell.getBgColor());\n            fg |= arr[0] << Attributes.RED_SHIFT | arr[1] << Attributes.GREEN_SHIFT | arr[2] << Attributes.BLUE_SHIFT;\n          case Attributes.CM_DEFAULT:\n          default:\n            const c2 = this._colors.background.rgba;\n            fg |= (c2 >> 8) & Attributes.RED_MASK | (c2 >> 8) & Attributes.GREEN_MASK | (c2 >> 8) & Attributes.BLUE_MASK;\n        }\n        fg |= Attributes.CM_RGB;\n      }\n      if (code & COMBINED_CHAR_BIT_MASK) {\n        if (!line) {\n          line = terminal.buffer.active.getLine(row);\n        }\n        const chars = line!.getCell(x)!.getChars();\n        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], bg, fg, chars);\n      } else {\n        this._updateCell(this._vertices.selectionAttributes, x, y, model.cells[offset], bg, fg);\n      }\n    }\n  }\n\n  private _getColorFromAnsiIndex(idx: number): IColor {\n    if (idx >= this._colors.ansi.length) {\n      throw new Error('No color found for idx ' + idx);\n    }\n    return this._colors.ansi[idx];\n  }\n\n  public onResize(): void {\n    const terminal = this._terminal;\n    const gl = this._gl;\n\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Update vertices\n    const newCount = terminal.cols * terminal.rows * INDICES_PER_CELL;\n    if (this._vertices.count !== newCount) {\n      this._vertices.count = newCount;\n      this._vertices.attributes = new Float32Array(newCount);\n      for (let i = 0; i < this._vertices.attributesBuffers.length; i++) {\n        this._vertices.attributesBuffers[i] = new Float32Array(newCount);\n      }\n\n      let i = 0;\n      for (let y = 0; y < terminal.rows; y++) {\n        for (let x = 0; x < terminal.cols; x++) {\n          this._vertices.attributes[i + 8] = x / terminal.cols;\n          this._vertices.attributes[i + 9] = y / terminal.rows;\n          i += INDICES_PER_CELL;\n        }\n      }\n    }\n  }\n\n  public setColors(): void {\n  }\n\n  public render(renderModel: IRenderModel, isSelectionVisible: boolean): void {\n    if (!this._atlas) {\n      return;\n    }\n\n    const gl = this._gl;\n\n    gl.useProgram(this._program);\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Alternate buffers each frame as the active buffer gets locked while it's in use by the GPU\n    this._activeBuffer = (this._activeBuffer + 1) % 2;\n    const activeBuffer = this._vertices.attributesBuffers[this._activeBuffer];\n\n    // Copy data for each cell of each line up to its line length (the last non-whitespace cell)\n    // from the attributes buffer into activeBuffer, which is the one that gets bound to the GPU.\n    // The reasons for this are as follows:\n    // - So the active buffer can be alternated so we don't get blocked on rendering finishing\n    // - To copy either the normal attributes buffer or the selection attributes buffer when there\n    //   is a selection\n    // - So we don't send vertices for all the line-ending whitespace to the GPU\n    let bufferLength = 0;\n    for (let y = 0; y < renderModel.lineLengths.length; y++) {\n      const si = y * this._terminal.cols * INDICES_PER_CELL;\n      const sub = (isSelectionVisible ? this._vertices.selectionAttributes : this._vertices.attributes).subarray(si, si + renderModel.lineLengths[y] * INDICES_PER_CELL);\n      activeBuffer.set(sub, bufferLength);\n      bufferLength += sub.length;\n    }\n\n    // Bind the attributes buffer\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, activeBuffer.subarray(0, bufferLength), gl.STREAM_DRAW);\n\n    // Bind the texture atlas if it's changed\n    if (this._atlas.hasCanvasChanged) {\n      this._atlas.hasCanvasChanged = false;\n      gl.uniform1i(this._textureLocation, 0);\n      gl.activeTexture(gl.TEXTURE0 + 0);\n      gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._atlas.cacheCanvas);\n      gl.generateMipmap(gl.TEXTURE_2D);\n    }\n\n    // Set uniforms\n    gl.uniformMatrix4fv(this._projectionLocation, false, PROJECTION_MATRIX);\n    gl.uniform2f(this._resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Draw the viewport\n    gl.drawElementsInstanced(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, bufferLength / INDICES_PER_CELL);\n  }\n\n  public setAtlas(atlas: WebglCharAtlas): void {\n    const gl = this._gl;\n    this._atlas = atlas;\n\n    gl.bindTexture(gl.TEXTURE_2D, this._atlasTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlas.cacheCanvas);\n    gl.generateMipmap(gl.TEXTURE_2D);\n  }\n\n  public setDimensions(dimensions: IRenderDimensions): void {\n    this._dimensions = dimensions;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { createProgram, expandFloat32Array, PROJECTION_MATRIX, throwIfFalsy } from './WebglUtils';\nimport { IRenderModel, IWebGLVertexArrayObject, IWebGL2RenderingContext, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\nimport { Attributes, FgFlags } from 'common/buffer/Constants';\nimport { Terminal } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { RENDER_MODEL_BG_OFFSET, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_INDICIES_PER_CELL } from './RenderModel';\n\nconst enum VertexAttribLocations {\n  POSITION = 0,\n  SIZE = 1,\n  COLOR = 2,\n  UNIT_QUAD = 3\n}\n\nconst vertexShaderSource = `#version 300 es\nlayout (location = ${VertexAttribLocations.POSITION}) in vec2 a_position;\nlayout (location = ${VertexAttribLocations.SIZE}) in vec2 a_size;\nlayout (location = ${VertexAttribLocations.COLOR}) in vec4 a_color;\nlayout (location = ${VertexAttribLocations.UNIT_QUAD}) in vec2 a_unitquad;\n\nuniform mat4 u_projection;\nuniform vec2 u_resolution;\n\nout vec4 v_color;\n\nvoid main() {\n  vec2 zeroToOne = (a_position + (a_unitquad * a_size)) / u_resolution;\n  gl_Position = u_projection * vec4(zeroToOne, 0.0, 1.0);\n  v_color = a_color;\n}`;\n\nconst fragmentShaderSource = `#version 300 es\nprecision lowp float;\n\nin vec4 v_color;\n\nout vec4 outColor;\n\nvoid main() {\n  outColor = v_color;\n}`;\n\ninterface IVertices {\n  attributes: Float32Array;\n  selection: Float32Array;\n  count: number;\n}\n\nconst INDICES_PER_RECTANGLE = 8;\nconst BYTES_PER_RECTANGLE = INDICES_PER_RECTANGLE * Float32Array.BYTES_PER_ELEMENT;\n\nconst INITIAL_BUFFER_RECTANGLE_CAPACITY = 20 * INDICES_PER_RECTANGLE;\n\nexport class RectangleRenderer {\n\n  private _program: WebGLProgram;\n  private _vertexArrayObject: IWebGLVertexArrayObject;\n  private _resolutionLocation: WebGLUniformLocation;\n  private _attributesBuffer: WebGLBuffer;\n  private _projectionLocation: WebGLUniformLocation;\n  private _bgFloat!: Float32Array;\n  private _selectionFloat!: Float32Array;\n\n  private _vertices: IVertices = {\n    count: 0,\n    attributes: new Float32Array(INITIAL_BUFFER_RECTANGLE_CAPACITY),\n    selection: new Float32Array(3 * INDICES_PER_RECTANGLE)\n  };\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private _gl: IWebGL2RenderingContext,\n    private _dimensions: IRenderDimensions\n  ) {\n    const gl = this._gl;\n\n    this._program = throwIfFalsy(createProgram(gl, vertexShaderSource, fragmentShaderSource));\n\n    // Uniform locations\n    this._resolutionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_resolution'));\n    this._projectionLocation = throwIfFalsy(gl.getUniformLocation(this._program, 'u_projection'));\n\n    // Create and set the vertex array object\n    this._vertexArrayObject = gl.createVertexArray();\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    // Setup a_unitquad, this defines the 4 vertices of a rectangle\n    const unitQuadVertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\n    const unitQuadVerticesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, unitQuadVerticesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, unitQuadVertices, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(VertexAttribLocations.UNIT_QUAD);\n    gl.vertexAttribPointer(VertexAttribLocations.UNIT_QUAD, 2, this._gl.FLOAT, false, 0, 0);\n\n    // Setup the unit quad element array buffer, this points to indices in\n    // unitQuadVertuces to allow is to draw 2 triangles from the vertices\n    const unitQuadElementIndices = new Uint8Array([0, 1, 3, 0, 2, 3]);\n    const elementIndicesBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, elementIndicesBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, unitQuadElementIndices, gl.STATIC_DRAW);\n\n    // Setup attributes\n    this._attributesBuffer = throwIfFalsy(gl.createBuffer());\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.enableVertexAttribArray(VertexAttribLocations.POSITION);\n    gl.vertexAttribPointer(VertexAttribLocations.POSITION, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 0);\n    gl.vertexAttribDivisor(VertexAttribLocations.POSITION, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.SIZE);\n    gl.vertexAttribPointer(VertexAttribLocations.SIZE, 2, gl.FLOAT, false, BYTES_PER_RECTANGLE, 2 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.SIZE, 1);\n    gl.enableVertexAttribArray(VertexAttribLocations.COLOR);\n    gl.vertexAttribPointer(VertexAttribLocations.COLOR, 4, gl.FLOAT, false, BYTES_PER_RECTANGLE, 4 * Float32Array.BYTES_PER_ELEMENT);\n    gl.vertexAttribDivisor(VertexAttribLocations.COLOR, 1);\n\n    this._updateCachedColors();\n  }\n\n  public render(): void {\n    const gl = this._gl;\n\n    gl.useProgram(this._program);\n\n    gl.bindVertexArray(this._vertexArrayObject);\n\n    gl.uniformMatrix4fv(this._projectionLocation, false, PROJECTION_MATRIX);\n    gl.uniform2f(this._resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Bind attributes buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.attributes, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, this._vertices.count);\n\n    // Bind selection buffer and draw\n    gl.bindBuffer(gl.ARRAY_BUFFER, this._attributesBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this._vertices.selection, gl.DYNAMIC_DRAW);\n    gl.drawElementsInstanced(this._gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0, 3);\n  }\n\n  public onResize(): void {\n    this._updateViewportRectangle();\n  }\n\n  public setColors(): void {\n    this._updateCachedColors();\n    this._updateViewportRectangle();\n  }\n\n  private _updateCachedColors(): void {\n    this._bgFloat = this._colorToFloat32Array(this._colors.background);\n    this._selectionFloat = this._colorToFloat32Array(this._colors.selectionOpaque);\n  }\n\n  private _updateViewportRectangle(): void {\n    // Set first rectangle that clears the screen\n    this._addRectangleFloat(\n      this._vertices.attributes,\n      0,\n      0,\n      0,\n      this._terminal.cols * this._dimensions.scaledCellWidth,\n      this._terminal.rows * this._dimensions.scaledCellHeight,\n      this._bgFloat\n    );\n  }\n\n  public updateSelection(model: ISelectionRenderModel): void {\n    const terminal = this._terminal;\n\n    if (!model.hasSelection) {\n      fill(this._vertices.selection, 0, 0);\n      return;\n    }\n\n    if (model.columnSelectMode) {\n      const startCol = model.startCol;\n      const width = model.endCol - startCol;\n      const height = model.viewportCappedEndRow - model.viewportCappedStartRow + 1;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        width * this._dimensions.scaledCellWidth,\n        height * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n      fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE);\n    } else {\n      // Draw first row\n      const startCol = model.viewportStartRow === model.viewportCappedStartRow ? model.startCol : 0;\n      const startRowEndCol = model.viewportCappedStartRow === model.viewportEndRow ? model.endCol : terminal.cols;\n      this._addRectangleFloat(\n        this._vertices.selection,\n        0,\n        startCol * this._dimensions.scaledCellWidth,\n        model.viewportCappedStartRow * this._dimensions.scaledCellHeight,\n        (startRowEndCol - startCol) * this._dimensions.scaledCellWidth,\n        this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw middle rows\n      const middleRowsCount = Math.max(model.viewportCappedEndRow - model.viewportCappedStartRow - 1, 0);\n      this._addRectangleFloat(\n        this._vertices.selection,\n        INDICES_PER_RECTANGLE,\n        0,\n        (model.viewportCappedStartRow + 1) * this._dimensions.scaledCellHeight,\n        terminal.cols * this._dimensions.scaledCellWidth,\n        middleRowsCount * this._dimensions.scaledCellHeight,\n        this._selectionFloat\n      );\n\n      // Draw final row\n      if (model.viewportCappedStartRow !== model.viewportCappedEndRow) {\n        // Only draw viewportEndRow if it's not the same as viewportStartRow\n        const endCol = model.viewportEndRow === model.viewportCappedEndRow ? model.endCol : terminal.cols;\n        this._addRectangleFloat(\n          this._vertices.selection,\n          INDICES_PER_RECTANGLE * 2,\n          0,\n          model.viewportCappedEndRow * this._dimensions.scaledCellHeight,\n          endCol * this._dimensions.scaledCellWidth,\n          this._dimensions.scaledCellHeight,\n          this._selectionFloat\n        );\n      } else {\n        fill(this._vertices.selection, 0, INDICES_PER_RECTANGLE * 2);\n      }\n    }\n  }\n\n  public updateBackgrounds(model: IRenderModel): void {\n    const terminal = this._terminal;\n    const vertices = this._vertices;\n\n    let rectangleCount = 1;\n\n    for (let y = 0; y < terminal.rows; y++) {\n      let currentStartX = -1;\n      let currentBg = 0;\n      let currentFg = 0;\n      let currentInverse = false;\n      for (let x = 0; x < terminal.cols; x++) {\n        const modelIndex = ((y * terminal.cols) + x) * RENDER_MODEL_INDICIES_PER_CELL;\n        const bg = model.cells[modelIndex + RENDER_MODEL_BG_OFFSET];\n        const fg = model.cells[modelIndex + RENDER_MODEL_FG_OFFSET];\n        const inverse = !!(fg & FgFlags.INVERSE);\n        if (bg !== currentBg || (fg !== currentFg && (currentInverse || inverse))) {\n          // A rectangle needs to be drawn if going from non-default to another color\n          if (currentBg !== 0 || (currentInverse && currentFg !== 0)) {\n            const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n            this._updateRectangle(vertices, offset, currentFg, currentBg, currentStartX, x, y);\n          }\n          currentStartX = x;\n          currentBg = bg;\n          currentFg = fg;\n          currentInverse = inverse;\n        }\n      }\n      // Finish rectangle if it's still going\n      if (currentBg !== 0 || (currentInverse && currentFg !== 0)) {\n        const offset = rectangleCount++ * INDICES_PER_RECTANGLE;\n        this._updateRectangle(vertices, offset, currentFg, currentBg, currentStartX, terminal.cols, y);\n      }\n    }\n    vertices.count = rectangleCount;\n  }\n\n  private _updateRectangle(vertices: IVertices, offset: number, fg: number, bg: number, startX: number, endX: number, y: number): void {\n    let rgba: number | undefined;\n    if (fg & FgFlags.INVERSE) {\n      switch (fg & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:\n          rgba = this._colors.ansi[fg & Attributes.PCOLOR_MASK].rgba;\n          break;\n        case Attributes.CM_RGB:\n          rgba = (fg & Attributes.RGB_MASK) << 8;\n          break;\n        case Attributes.CM_DEFAULT:\n        default:\n          rgba = this._colors.foreground.rgba;\n      }\n    } else {\n      switch (bg & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:\n          rgba = this._colors.ansi[bg & Attributes.PCOLOR_MASK].rgba;\n          break;\n        case Attributes.CM_RGB:\n          rgba = (bg & Attributes.RGB_MASK) << 8;\n          break;\n        case Attributes.CM_DEFAULT:\n        default:\n          rgba = this._colors.background.rgba;\n      }\n    }\n\n    if (vertices.attributes.length < offset + 4) {\n      vertices.attributes = expandFloat32Array(vertices.attributes, this._terminal.rows * this._terminal.cols * INDICES_PER_RECTANGLE);\n    }\n    const x1 = startX * this._dimensions.scaledCellWidth;\n    const y1 = y * this._dimensions.scaledCellHeight;\n    const r = ((rgba >> 24) & 0xFF) / 255;\n    const g = ((rgba >> 16) & 0xFF) / 255;\n    const b = ((rgba >> 8 ) & 0xFF) / 255;\n\n    this._addRectangle(vertices.attributes, offset, x1, y1, (endX - startX) * this._dimensions.scaledCellWidth, this._dimensions.scaledCellHeight, r, g, b, 1);\n  }\n\n  private _addRectangle(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, r: number, g: number, b: number, a: number): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = r;\n    array[offset + 5] = g;\n    array[offset + 6] = b;\n    array[offset + 7] = a;\n  }\n\n  private _addRectangleFloat(array: Float32Array, offset: number, x1: number, y1: number, width: number, height: number, color: Float32Array): void {\n    array[offset    ] = x1;\n    array[offset + 1] = y1;\n    array[offset + 2] = width;\n    array[offset + 3] = height;\n    array[offset + 4] = color[0];\n    array[offset + 5] = color[1];\n    array[offset + 6] = color[2];\n    array[offset + 7] = color[3];\n  }\n\n  private _colorToFloat32Array(color: IColor): Float32Array {\n    return new Float32Array([\n      ((color.rgba >> 24) & 0xFF) / 255,\n      ((color.rgba >> 16) & 0xFF) / 255,\n      ((color.rgba >> 8 ) & 0xFF) / 255,\n      ((color.rgba      ) & 0xFF) / 255\n    ]);\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderModel, ISelectionRenderModel } from './Types';\nimport { fill } from 'common/TypedArrayUtils';\n\nexport const RENDER_MODEL_INDICIES_PER_CELL = 3;\nexport const RENDER_MODEL_BG_OFFSET = 1;\nexport const RENDER_MODEL_FG_OFFSET = 2;\n\nexport const COMBINED_CHAR_BIT_MASK = 0x80000000;\n\nexport class RenderModel implements IRenderModel {\n  public cells: Uint32Array;\n  public lineLengths: Uint32Array;\n  public selection: ISelectionRenderModel;\n\n  constructor() {\n    this.cells = new Uint32Array(0);\n    this.lineLengths = new Uint32Array(0);\n    this.selection = {\n      hasSelection: false,\n      columnSelectMode: false,\n      viewportStartRow: 0,\n      viewportEndRow: 0,\n      viewportCappedStartRow: 0,\n      viewportCappedEndRow: 0,\n      startCol: 0,\n      endCol: 0\n    };\n  }\n\n  public resize(cols: number, rows: number): void {\n    const indexCount = cols * rows * RENDER_MODEL_INDICIES_PER_CELL;\n    if (indexCount !== this.cells.length) {\n      this.cells = new Uint32Array(indexCount);\n      this.lineLengths = new Uint32Array(rows);\n    }\n  }\n\n  public clear(): void {\n    fill(this.cells, 0, 0);\n    fill(this.lineLengths, 0, 0);\n  }\n\n  public clearSelection(): void {\n    this.selection.hasSelection = false;\n    this.selection.viewportStartRow = 0;\n    this.selection.viewportEndRow = 0;\n    this.selection.viewportCappedStartRow = 0;\n    this.selection.viewportCappedEndRow = 0;\n    this.selection.startCol = 0;\n    this.selection.endCol = 0;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n\nexport function slice<T extends TypedArray>(array: T, start?: number, end?: number): T {\n  // all modern engines that support .slice\n  if (array.slice) {\n    return array.slice(start, end) as T;\n  }\n  return sliceFallback(array, start, end);\n}\n\nexport function sliceFallback<T extends TypedArray>(array: T, start: number = 0, end: number = array.length): T {\n  if (start < 0) {\n    start = (array.length + start) % array.length;\n  }\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  start = Math.min(start, end);\n\n  const result: T = new (array.constructor as any)(end - start);\n  for (let i = 0; i < end - start; ++i) {\n    result[i] = array[i + start];\n  }\n  return result;\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { GlyphRenderer } from './GlyphRenderer';\nimport { LinkRenderLayer } from './renderLayer/LinkRenderLayer';\nimport { CursorRenderLayer } from './renderLayer/CursorRenderLayer';\nimport { acquireCharAtlas } from './atlas/CharAtlasCache';\nimport { WebglCharAtlas } from './atlas/WebglCharAtlas';\nimport { RectangleRenderer } from './RectangleRenderer';\nimport { IWebGL2RenderingContext } from './Types';\nimport { RenderModel, COMBINED_CHAR_BIT_MASK, RENDER_MODEL_BG_OFFSET, RENDER_MODEL_FG_OFFSET, RENDER_MODEL_INDICIES_PER_CELL } from './RenderModel';\nimport { Disposable } from 'common/Lifecycle';\nimport { Content, NULL_CELL_CHAR, NULL_CELL_CODE } from 'common/buffer/Constants';\nimport { Terminal, IEvent } from 'xterm';\nimport { IRenderLayer } from './renderLayer/Types';\nimport { IRenderDimensions, IRenderer, IRequestRedrawEvent } from 'browser/renderer/Types';\nimport { ITerminal, IColorSet } from 'browser/Types';\nimport { EventEmitter } from 'common/EventEmitter';\nimport { CellData } from 'common/buffer/CellData';\nimport { addDisposableDomListener } from 'browser/Lifecycle';\nimport { ICharacterJoinerService } from 'browser/services/Services';\nimport { CharData, ICellData } from 'common/Types';\nimport { AttributeData } from 'common/buffer/AttributeData';\n\nexport class WebglRenderer extends Disposable implements IRenderer {\n  private _renderLayers: IRenderLayer[];\n  private _charAtlas: WebglCharAtlas | undefined;\n  private _devicePixelRatio: number;\n\n  private _model: RenderModel = new RenderModel();\n  private _workCell: CellData = new CellData();\n\n  private _canvas: HTMLCanvasElement;\n  private _gl: IWebGL2RenderingContext;\n  private _rectangleRenderer: RectangleRenderer;\n  private _glyphRenderer: GlyphRenderer;\n\n  public dimensions: IRenderDimensions;\n\n  private _core: ITerminal;\n  private _isAttached: boolean;\n\n  private _onRequestRedraw = new EventEmitter<IRequestRedrawEvent>();\n  public get onRequestRedraw(): IEvent<IRequestRedrawEvent> { return this._onRequestRedraw.event; }\n\n  private _onContextLoss = new EventEmitter<void>();\n  public get onContextLoss(): IEvent<void> { return this._onContextLoss.event; }\n\n  constructor(\n    private _terminal: Terminal,\n    private _colors: IColorSet,\n    private readonly _characterJoinerService: ICharacterJoinerService,\n    preserveDrawingBuffer?: boolean\n  ) {\n    super();\n\n    this._core = (this._terminal as any)._core;\n\n    this._renderLayers = [\n      new LinkRenderLayer(this._core.screenElement!, 2, this._colors, this._core),\n      new CursorRenderLayer(this._core.screenElement!, 3, this._colors, this._onRequestRedraw)\n    ];\n    this.dimensions = {\n      scaledCharWidth: 0,\n      scaledCharHeight: 0,\n      scaledCellWidth: 0,\n      scaledCellHeight: 0,\n      scaledCharLeft: 0,\n      scaledCharTop: 0,\n      scaledCanvasWidth: 0,\n      scaledCanvasHeight: 0,\n      canvasWidth: 0,\n      canvasHeight: 0,\n      actualCellWidth: 0,\n      actualCellHeight: 0\n    };\n    this._devicePixelRatio = window.devicePixelRatio;\n    this._updateDimensions();\n\n    this._canvas = document.createElement('canvas');\n\n    const contextAttributes = {\n      antialias: false,\n      depth: false,\n      preserveDrawingBuffer\n    };\n    this._gl = this._canvas.getContext('webgl2', contextAttributes) as IWebGL2RenderingContext;\n    if (!this._gl) {\n      throw new Error('WebGL2 not supported ' + this._gl);\n    }\n\n    this.register(addDisposableDomListener(this._canvas, 'webglcontextlost', (e) => { this._onContextLoss.fire(e); }));\n\n    this._core.screenElement!.appendChild(this._canvas);\n\n    this._rectangleRenderer = new RectangleRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n    this._glyphRenderer = new GlyphRenderer(this._terminal, this._colors, this._gl, this.dimensions);\n\n    // Update dimensions and acquire char atlas\n    this.onCharSizeChanged();\n\n    this._isAttached = document.body.contains(this._core.screenElement!);\n  }\n\n  public dispose(): void {\n    for (const l of this._renderLayers) {\n      l.dispose();\n    }\n    this._core.screenElement!.removeChild(this._canvas);\n    super.dispose();\n  }\n\n  public get textureAtlas(): HTMLCanvasElement | undefined {\n    return this._charAtlas?.cacheCanvas;\n  }\n\n  public setColors(colors: IColorSet): void {\n    this._colors = colors;\n    // Clear layers and force a full render\n    for (const l of this._renderLayers) {\n      l.setColors(this._terminal, this._colors);\n      l.reset(this._terminal);\n    }\n\n    this._rectangleRenderer.setColors();\n    this._glyphRenderer.setColors();\n\n    this._refreshCharAtlas();\n\n    // Force a full refresh\n    this._model.clear();\n  }\n\n  public onDevicePixelRatioChange(): void {\n    // If the device pixel ratio changed, the char atlas needs to be regenerated\n    // and the terminal needs to refreshed\n    if (this._devicePixelRatio !== window.devicePixelRatio) {\n      this._devicePixelRatio = window.devicePixelRatio;\n      this.onResize(this._terminal.cols, this._terminal.rows);\n    }\n  }\n\n  public onResize(cols: number, rows: number): void {\n    // Update character and canvas dimensions\n    this._updateDimensions();\n\n    this._model.resize(this._terminal.cols, this._terminal.rows);\n\n    // Resize all render layers\n    for (const l of this._renderLayers) {\n      l.resize(this._terminal, this.dimensions);\n    }\n\n    // Resize the canvas\n    this._canvas.width = this.dimensions.scaledCanvasWidth;\n    this._canvas.height = this.dimensions.scaledCanvasHeight;\n    this._canvas.style.width = `${this.dimensions.canvasWidth}px`;\n    this._canvas.style.height = `${this.dimensions.canvasHeight}px`;\n\n    // Resize the screen\n    this._core.screenElement!.style.width = `${this.dimensions.canvasWidth}px`;\n    this._core.screenElement!.style.height = `${this.dimensions.canvasHeight}px`;\n\n    this._rectangleRenderer.onResize();\n    if (this._model.selection.hasSelection) {\n      // Update selection as dimensions have changed\n      this._rectangleRenderer.updateSelection(this._model.selection);\n    }\n\n    this._glyphRenderer.setDimensions(this.dimensions);\n    this._glyphRenderer.onResize();\n\n    this._refreshCharAtlas();\n\n    // Force a full refresh\n    this._model.clear();\n  }\n\n  public onCharSizeChanged(): void {\n    this.onResize(this._terminal.cols, this._terminal.rows);\n  }\n\n  public onBlur(): void {\n    for (const l of this._renderLayers) {\n      l.onBlur(this._terminal);\n    }\n  }\n\n  public onFocus(): void {\n    for (const l of this._renderLayers) {\n      l.onFocus(this._terminal);\n    }\n  }\n\n  public onSelectionChanged(start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean): void {\n    for (const l of this._renderLayers) {\n      l.onSelectionChanged(this._terminal, start, end, columnSelectMode);\n    }\n\n    this._updateSelectionModel(start, end, columnSelectMode);\n\n    this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });\n  }\n\n  public onCursorMove(): void {\n    for (const l of this._renderLayers) {\n      l.onCursorMove(this._terminal);\n    }\n  }\n\n  public onOptionsChanged(): void {\n    for (const l of this._renderLayers) {\n      l.onOptionsChanged(this._terminal);\n    }\n    this._updateDimensions();\n    this._refreshCharAtlas();\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(): void {\n    if (this.dimensions.scaledCharWidth <= 0 && this.dimensions.scaledCharHeight <= 0) {\n      // Mark as not attached so char atlas gets refreshed on next render\n      this._isAttached = false;\n      return;\n    }\n\n    const atlas = acquireCharAtlas(this._terminal, this._colors, this.dimensions.scaledCharWidth, this.dimensions.scaledCharHeight);\n    if (!('getRasterizedGlyph' in atlas)) {\n      throw new Error('The webgl renderer only works with the webgl char atlas');\n    }\n    this._charAtlas = atlas as WebglCharAtlas;\n    this._charAtlas.warmUp();\n    this._glyphRenderer.setAtlas(this._charAtlas);\n  }\n\n  public clearCharAtlas(): void {\n    this._charAtlas?.clearTexture();\n    this._model.clear();\n    this._updateModel(0, this._terminal.rows - 1);\n    this._onRequestRedraw.fire({ start: 0, end: this._terminal.rows - 1 });\n  }\n\n  public clear(): void {\n    for (const l of this._renderLayers) {\n      l.reset(this._terminal);\n    }\n  }\n\n  public registerCharacterJoiner(handler: (text: string) => [number, number][]): number {\n    return -1;\n  }\n\n  public deregisterCharacterJoiner(joinerId: number): boolean {\n    return false;\n  }\n\n  public renderRows(start: number, end: number): void {\n    if (!this._isAttached) {\n      if (document.body.contains(this._core.screenElement!) && (this._core as any)._charSizeService.width && (this._core as any)._charSizeService.height) {\n        this._updateDimensions();\n        this._refreshCharAtlas();\n        this._isAttached = true;\n      } else {\n        return;\n      }\n    }\n\n    // Update render layers\n    for (const l of this._renderLayers) {\n      l.onGridChanged(this._terminal, start, end);\n    }\n\n    // Tell renderer the frame is beginning\n    if (this._glyphRenderer.beginFrame()) {\n      this._model.clear();\n      this._updateSelectionModel(undefined, undefined);\n    }\n\n    // Update model to reflect what's drawn\n    this._updateModel(start, end);\n\n    // Render\n    this._rectangleRenderer.render();\n    this._glyphRenderer.render(this._model, this._model.selection.hasSelection);\n  }\n\n  private _updateModel(start: number, end: number): void {\n    const terminal = this._core;\n    let cell: ICellData = this._workCell;\n\n    for (let y = start; y <= end; y++) {\n      const row = y + terminal.buffer.ydisp;\n      const line = terminal.buffer.lines.get(row)!;\n      this._model.lineLengths[y] = 0;\n      const joinedRanges = this._characterJoinerService.getJoinedCharacters(row);\n      for (let x = 0; x < terminal.cols; x++) {\n        line.loadCell(x, cell);\n\n        // If true, indicates that the current character(s) to draw were joined.\n        let isJoined = false;\n        let lastCharX = x;\n\n        // Process any joined character ranges as needed. Because of how the\n        // ranges are produced, we know that they are valid for the characters\n        // and attributes of our input.\n        if (joinedRanges.length > 0 && x === joinedRanges[0][0]) {\n          isJoined = true;\n          const range = joinedRanges.shift()!;\n\n          // We already know the exact start and end column of the joined range,\n          // so we get the string and width representing it directly\n          cell = new JoinedCellData(\n            cell,\n            line!.translateToString(true, range[0], range[1]),\n            range[1] - range[0]\n          );\n\n          // Skip over the cells occupied by this range in the loop\n          lastCharX = range[1] - 1;\n        }\n\n        const chars = cell.getChars();\n        let code = cell.getCode();\n        const i = ((y * terminal.cols) + x) * RENDER_MODEL_INDICIES_PER_CELL;\n\n        if (code !== NULL_CELL_CODE) {\n          this._model.lineLengths[y] = x + 1;\n        }\n\n        // Nothing has changed, no updates needed\n        if (this._model.cells[i] === code &&\n            this._model.cells[i + RENDER_MODEL_BG_OFFSET] === cell.bg &&\n            this._model.cells[i + RENDER_MODEL_FG_OFFSET] === cell.fg) {\n          continue;\n        }\n\n        // Flag combined chars with a bit mask so they're easily identifiable\n        if (chars.length > 1) {\n          code = code | COMBINED_CHAR_BIT_MASK;\n        }\n\n        // Cache the results in the model\n        this._model.cells[i] = code;\n        this._model.cells[i + RENDER_MODEL_BG_OFFSET] = cell.bg;\n        this._model.cells[i + RENDER_MODEL_FG_OFFSET] = cell.fg;\n\n        this._glyphRenderer.updateCell(x, y, code, cell.bg, cell.fg, chars);\n\n        if (isJoined) {\n          // Restore work cell\n          cell = this._workCell;\n\n          // Null out non-first cells\n          for (x++; x < lastCharX; x++) {\n            const j = ((y * terminal.cols) + x) * RENDER_MODEL_INDICIES_PER_CELL;\n            this._glyphRenderer.updateCell(x, y, NULL_CELL_CODE, 0, 0, NULL_CELL_CHAR);\n            this._model.cells[j] = NULL_CELL_CODE;\n            this._model.cells[j + RENDER_MODEL_BG_OFFSET] = this._workCell.bg;\n            this._model.cells[j + RENDER_MODEL_FG_OFFSET] = this._workCell.fg;\n          }\n        }\n      }\n    }\n    this._rectangleRenderer.updateBackgrounds(this._model);\n    if (this._model.selection.hasSelection) {\n      // Model could be updated but the selection is unchanged\n      this._glyphRenderer.updateSelection(this._model);\n    }\n  }\n\n  private _updateSelectionModel(start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean = false): void {\n    const terminal = this._terminal;\n\n    // Selection does not exist\n    if (!start || !end || (start[0] === end[0] && start[1] === end[1])) {\n      this._model.clearSelection();\n      this._rectangleRenderer.updateSelection(this._model.selection);\n      return;\n    }\n\n    // Translate from buffer position to viewport position\n    const viewportStartRow = start[1] - terminal.buffer.active.viewportY;\n    const viewportEndRow = end[1] - terminal.buffer.active.viewportY;\n    const viewportCappedStartRow = Math.max(viewportStartRow, 0);\n    const viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);\n\n    // No need to draw the selection\n    if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {\n      this._model.clearSelection();\n      this._rectangleRenderer.updateSelection(this._model.selection);\n      return;\n    }\n\n    this._model.selection.hasSelection = true;\n    this._model.selection.columnSelectMode = columnSelectMode;\n    this._model.selection.viewportStartRow = viewportStartRow;\n    this._model.selection.viewportEndRow = viewportEndRow;\n    this._model.selection.viewportCappedStartRow = viewportCappedStartRow;\n    this._model.selection.viewportCappedEndRow = viewportCappedEndRow;\n    this._model.selection.startCol = start[0];\n    this._model.selection.endCol = end[0];\n\n    this._rectangleRenderer.updateSelection(this._model.selection);\n  }\n\n  /**\n   * Recalculates the character and canvas dimensions.\n   */\n  private _updateDimensions(): void {\n    // TODO: Acquire CharSizeService properly\n\n    // Perform a new measure if the CharMeasure dimensions are not yet available\n    if (!(this._core as any)._charSizeService.width || !(this._core as any)._charSizeService.height) {\n      return;\n    }\n\n    // Calculate the scaled character width. Width is floored as it must be\n    // drawn to an integer grid in order for the CharAtlas \"stamps\" to not be\n    // blurry. When text is drawn to the grid not using the CharAtlas, it is\n    // clipped to ensure there is no overlap with the next cell.\n\n    // NOTE: ceil fixes sometime, floor does others :s\n\n    this.dimensions.scaledCharWidth = Math.floor((this._core as any)._charSizeService.width * this._devicePixelRatio);\n\n    // Calculate the scaled character height. Height is ceiled in case\n    // devicePixelRatio is a floating point number in order to ensure there is\n    // enough space to draw the character to the cell.\n    this.dimensions.scaledCharHeight = Math.ceil((this._core as any)._charSizeService.height * this._devicePixelRatio);\n\n    // Calculate the scaled cell height, if lineHeight is not 1 then the value\n    // will be floored because since lineHeight can never be lower then 1, there\n    // is a guarentee that the scaled line height will always be larger than\n    // scaled char height.\n    this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.getOption('lineHeight'));\n\n    // Calculate the y coordinate within a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharTop = this._terminal.getOption('lineHeight') === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);\n\n    // Calculate the scaled cell width, taking the letterSpacing into account.\n    this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.getOption('letterSpacing'));\n\n    // Calculate the x coordinate with a cell that text should draw from in\n    // order to draw in the center of a cell.\n    this.dimensions.scaledCharLeft = Math.floor(this._terminal.getOption('letterSpacing') / 2);\n\n    // Recalculate the canvas dimensions; scaled* define the actual number of\n    // pixel in the canvas\n    this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;\n    this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;\n\n    // The the size of the canvas on the page. It's very important that this\n    // rounds to nearest integer and not ceils as browsers often set\n    // window.devicePixelRatio as something like 1.100000023841858, when it's\n    // actually 1.1. Ceiling causes blurriness as the backing canvas image is 1\n    // pixel too large for the canvas element size.\n    this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / this._devicePixelRatio);\n    this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / this._devicePixelRatio);\n\n    // this.dimensions.scaledCanvasHeight = this.dimensions.canvasHeight * devicePixelRatio;\n    // this.dimensions.scaledCanvasWidth = this.dimensions.canvasWidth * devicePixelRatio;\n\n    // Get the _actual_ dimensions of an individual cell. This needs to be\n    // derived from the canvasWidth/Height calculated above which takes into\n    // account window.devicePixelRatio. CharMeasure.width/height by itself is\n    // insufficient when the page is not at 100% zoom level as CharMeasure is\n    // measured in CSS pixels, but the actual char size on the canvas can\n    // differ.\n    // this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;\n    // this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;\n\n    // This fixes 110% and 125%, not 150% or 175% though\n    this.dimensions.actualCellHeight = this.dimensions.scaledCellHeight / this._devicePixelRatio;\n    this.dimensions.actualCellWidth = this.dimensions.scaledCellWidth / this._devicePixelRatio;\n  }\n}\n\n// TODO: Share impl with core\nexport class JoinedCellData extends AttributeData implements ICellData {\n  private _width: number;\n  // .content carries no meaning for joined CellData, simply nullify it\n  // thus we have to overload all other .content accessors\n  public content: number = 0;\n  public fg: number;\n  public bg: number;\n  public combinedData: string = '';\n\n  constructor(firstCell: ICellData, chars: string, width: number) {\n    super();\n    this.fg = firstCell.fg;\n    this.bg = firstCell.bg;\n    this.combinedData = chars;\n    this._width = width;\n  }\n\n  public isCombined(): number {\n    // always mark joined cell data as combined\n    return Content.IS_COMBINED_MASK;\n  }\n\n  public getWidth(): number {\n    return this._width;\n  }\n\n  public getChars(): string {\n    return this.combinedData;\n  }\n\n  public getCode(): number {\n    // code always gets the highest possible fake codepoint (read as -1)\n    // this is needed as code is used by caches as identifier\n    return 0x1FFFFF;\n  }\n\n  public setFromCharData(value: CharData): void {\n    throw new Error('not implemented');\n  }\n\n  public getAsCharData(): CharData {\n    return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * A matrix that when multiplies will translate 0-1 coordinates (left to right,\n * top to bottom) to clip space.\n */\nexport const PROJECTION_MATRIX = new Float32Array([\n  2, 0, 0, 0,\n  0, -2, 0, 0,\n  0, 0, 1, 0,\n  -1, 1, 0, 1\n]);\n\nexport function createProgram(gl: WebGLRenderingContext, vertexSource: string, fragmentSource: string): WebGLProgram | undefined {\n  const program = throwIfFalsy(gl.createProgram());\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.VERTEX_SHADER, vertexSource)));\n  gl.attachShader(program, throwIfFalsy(createShader(gl, gl.FRAGMENT_SHADER, fragmentSource)));\n  gl.linkProgram(program);\n  const success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program;\n  }\n\n  console.error(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n}\n\nexport function createShader(gl: WebGLRenderingContext, type: number, source: string): WebGLShader | undefined {\n  const shader = throwIfFalsy(gl.createShader(type));\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader;\n  }\n\n  console.error(gl.getShaderInfoLog(shader));\n  gl.deleteShader(shader);\n}\n\nexport function expandFloat32Array(source: Float32Array, max: number): Float32Array {\n  const newLength = Math.min(source.length * 2, max);\n  const newArray = new Float32Array(newLength);\n  for (let i = 0; i < source.length; i++) {\n    newArray[i] = source[i];\n  }\n  return newArray;\n}\n\nexport function throwIfFalsy<T>(value: T | undefined | null): T {\n  if (!value) {\n    throw new Error('value must not be falsy');\n  }\n  return value;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { generateConfig, configEquals } from './CharAtlasUtils';\nimport { WebglCharAtlas } from './WebglCharAtlas';\nimport { ICharAtlasConfig } from './Types';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\n\ninterface ICharAtlasCacheEntry {\n  atlas: WebglCharAtlas;\n  config: ICharAtlasConfig;\n  // N.B. This implementation potentially holds onto copies of the terminal forever, so\n  // this may cause memory leaks.\n  ownedBy: Terminal[];\n}\n\nconst charAtlasCache: ICharAtlasCacheEntry[] = [];\n\n/**\n * Acquires a char atlas, either generating a new one or returning an existing\n * one that is in use by another terminal.\n * @param terminal The terminal.\n * @param colors The colors to use.\n */\nexport function acquireCharAtlas(\n  terminal: Terminal,\n  colors: IColorSet,\n  scaledCharWidth: number,\n  scaledCharHeight: number\n): WebglCharAtlas {\n  const newConfig = generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);\n\n  // Check to see if the terminal already owns this config\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    const ownedByIndex = entry.ownedBy.indexOf(terminal);\n    if (ownedByIndex >= 0) {\n      if (configEquals(entry.config, newConfig)) {\n        return entry.atlas;\n      }\n      // The configs differ, release the terminal from the entry\n      if (entry.ownedBy.length === 1) {\n        entry.atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        entry.ownedBy.splice(ownedByIndex, 1);\n      }\n      break;\n    }\n  }\n\n  // Try match a char atlas from the cache\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const entry = charAtlasCache[i];\n    if (configEquals(entry.config, newConfig)) {\n      // Add the terminal to the cache entry and return\n      entry.ownedBy.push(terminal);\n      return entry.atlas;\n    }\n  }\n\n  const newEntry: ICharAtlasCacheEntry = {\n    atlas: new WebglCharAtlas(document, newConfig),\n    config: newConfig,\n    ownedBy: [terminal]\n  };\n  charAtlasCache.push(newEntry);\n  return newEntry.atlas;\n}\n\n/**\n * Removes a terminal reference from the cache, allowing its memory to be freed.\n * @param terminal The terminal to remove.\n */\nexport function removeTerminalFromCache(terminal: Terminal): void {\n  for (let i = 0; i < charAtlasCache.length; i++) {\n    const index = charAtlasCache[i].ownedBy.indexOf(terminal);\n    if (index !== -1) {\n      if (charAtlasCache[i].ownedBy.length === 1) {\n        // Remove the cache entry if it's the only terminal\n        charAtlasCache[i].atlas.dispose();\n        charAtlasCache.splice(i, 1);\n      } else {\n        // Remove the reference from the cache entry\n        charAtlasCache[i].ownedBy.splice(index, 1);\n      }\n      break;\n    }\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { Attributes } from 'common/buffer/Constants';\nimport { Terminal, FontWeight } from 'xterm';\nimport { IColorSet, IColor } from 'browser/Types';\n\nconst NULL_COLOR: IColor = {\n  css: '',\n  rgba: 0\n};\n\nexport function generateConfig(scaledCharWidth: number, scaledCharHeight: number, terminal: Terminal, colors: IColorSet): ICharAtlasConfig {\n  // null out some fields that don't matter\n  const clonedColors: IColorSet = {\n    foreground: colors.foreground,\n    background: colors.background,\n    cursor: NULL_COLOR,\n    cursorAccent: NULL_COLOR,\n    selectionTransparent: NULL_COLOR,\n    selectionOpaque: NULL_COLOR,\n    // For the static char atlas, we only use the first 16 colors, but we need all 256 for the\n    // dynamic character atlas.\n    ansi: colors.ansi.slice(),\n    contrastCache: colors.contrastCache\n  };\n  return {\n    devicePixelRatio: window.devicePixelRatio,\n    scaledCharWidth,\n    scaledCharHeight,\n    fontFamily: terminal.getOption('fontFamily'),\n    fontSize: terminal.getOption('fontSize'),\n    fontWeight: terminal.getOption('fontWeight') as FontWeight,\n    fontWeightBold: terminal.getOption('fontWeightBold') as FontWeight,\n    allowTransparency: terminal.getOption('allowTransparency'),\n    drawBoldTextInBrightColors: terminal.getOption('drawBoldTextInBrightColors'),\n    minimumContrastRatio: terminal.getOption('minimumContrastRatio'),\n    colors: clonedColors\n  };\n}\n\nexport function configEquals(a: ICharAtlasConfig, b: ICharAtlasConfig): boolean {\n  for (let i = 0; i < a.colors.ansi.length; i++) {\n    if (a.colors.ansi[i].rgba !== b.colors.ansi[i].rgba) {\n      return false;\n    }\n  }\n  return a.devicePixelRatio === b.devicePixelRatio &&\n      a.fontFamily === b.fontFamily &&\n      a.fontSize === b.fontSize &&\n      a.fontWeight === b.fontWeight &&\n      a.fontWeightBold === b.fontWeightBold &&\n      a.allowTransparency === b.allowTransparency &&\n      a.scaledCharWidth === b.scaledCharWidth &&\n      a.scaledCharHeight === b.scaledCharHeight &&\n      a.drawBoldTextInBrightColors === b.drawBoldTextInBrightColors &&\n      a.minimumContrastRatio === b.minimumContrastRatio &&\n      a.colors.foreground === b.colors.foreground &&\n      a.colors.background === b.colors.background;\n}\n\nexport function is256Color(colorCode: number): boolean {\n  return (colorCode & Attributes.CM_MASK) === Attributes.CM_P16 || (colorCode & Attributes.CM_MASK) === Attributes.CM_P256;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ICharAtlasConfig } from './Types';\nimport { DIM_OPACITY } from 'browser/renderer/atlas/Constants';\nimport { IRasterizedGlyph, IBoundingBox, IRasterizedGlyphSet } from '../Types';\nimport { DEFAULT_COLOR, Attributes } from 'common/buffer/Constants';\nimport { throwIfFalsy } from '../WebglUtils';\nimport { IColor } from 'browser/Types';\nimport { IDisposable } from 'xterm';\nimport { AttributeData } from 'common/buffer/AttributeData';\nimport { channels, rgba } from 'browser/Color';\n\n// In practice we're probably never going to exhaust a texture this large. For debugging purposes,\n// however, it can be useful to set this to a really tiny value, to verify that LRU eviction works.\nconst TEXTURE_WIDTH = 1024;\nconst TEXTURE_HEIGHT = 1024;\n\n/**\n * The amount of the texture to be filled before throwing it away and starting\n * again. Since the throw away and individual glyph draws don't cost too much,\n * this prevent juggling multiple textures in the GL context.\n */\nconst TEXTURE_CAPACITY = Math.floor(TEXTURE_HEIGHT * 0.8);\n\nconst TRANSPARENT_COLOR = {\n  css: 'rgba(0, 0, 0, 0)',\n  rgba: 0\n};\n\n/**\n * A shared object which is used to draw nothing for a particular cell.\n */\nconst NULL_RASTERIZED_GLYPH: IRasterizedGlyph = {\n  offset: { x: 0, y: 0 },\n  texturePosition: { x: 0, y: 0 },\n  texturePositionClipSpace: { x: 0, y: 0 },\n  size: { x: 0, y: 0 },\n  sizeClipSpace: { x: 0, y: 0 }\n};\n\nconst TMP_CANVAS_GLYPH_PADDING = 2;\n\nexport class WebglCharAtlas implements IDisposable {\n  private _didWarmUp: boolean = false;\n\n  private _cacheMap: { [code: number]: IRasterizedGlyphSet } = {};\n  private _cacheMapCombined: { [chars: string]: IRasterizedGlyphSet } = {};\n\n  // The texture that the atlas is drawn to\n  public cacheCanvas: HTMLCanvasElement;\n  private _cacheCtx: CanvasRenderingContext2D;\n\n  private _tmpCanvas: HTMLCanvasElement;\n  // A temporary context that glyphs are drawn to before being transfered to the atlas.\n  private _tmpCtx: CanvasRenderingContext2D;\n\n  // Since glyphs are expected to be around the same height, the packing\n  // strategy used it to fill a row with glyphs while keeping track of the\n  // tallest glyph in the row. Once the row is full a new row is started at\n  // (0,lastRow+lastRowTallestGlyph).\n  private _currentRowY: number = 0;\n  private _currentRowX: number = 0;\n  private _currentRowHeight: number = 0;\n\n  public hasCanvasChanged = false;\n\n  private _workBoundingBox: IBoundingBox = { top: 0, left: 0, bottom: 0, right: 0 };\n  private _workAttributeData: AttributeData = new AttributeData();\n\n  constructor(\n    document: Document,\n    private _config: ICharAtlasConfig\n  ) {\n    this.cacheCanvas = document.createElement('canvas');\n    this.cacheCanvas.width = TEXTURE_WIDTH;\n    this.cacheCanvas.height = TEXTURE_HEIGHT;\n    // The canvas needs alpha because we use clearColor to convert the background color to alpha.\n    // It might also contain some characters with transparent backgrounds if allowTransparency is\n    // set.\n    this._cacheCtx = throwIfFalsy(this.cacheCanvas.getContext('2d', { alpha: true }));\n\n    this._tmpCanvas = document.createElement('canvas');\n    this._tmpCanvas.width = this._config.scaledCharWidth * 4 + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCanvas.height = this._config.scaledCharHeight + TMP_CANVAS_GLYPH_PADDING * 2;\n    this._tmpCtx = throwIfFalsy(this._tmpCanvas.getContext('2d', { alpha: this._config.allowTransparency }));\n  }\n\n  public dispose(): void {\n    if (this.cacheCanvas.parentElement) {\n      this.cacheCanvas.parentElement.removeChild(this.cacheCanvas);\n    }\n  }\n\n  public warmUp(): void {\n    if (!this._didWarmUp) {\n      this._doWarmUp();\n      this._didWarmUp = true;\n    }\n  }\n\n  private _doWarmUp(): void {\n    // Pre-fill with ASCII 33-126\n    for (let i = 33; i < 126; i++) {\n      const rasterizedGlyph = this._drawToCache(i, DEFAULT_COLOR, DEFAULT_COLOR);\n      this._cacheMap[i] = {\n        [DEFAULT_COLOR]: {\n          [DEFAULT_COLOR]: rasterizedGlyph\n        }\n      };\n    }\n  }\n\n  public beginFrame(): boolean {\n    if (this._currentRowY > TEXTURE_CAPACITY) {\n      this.clearTexture();\n      this.warmUp();\n      return true;\n    }\n    return false;\n  }\n\n  public clearTexture(): void {\n    if (this._currentRowX === 0 && this._currentRowY === 0) {\n      return;\n    }\n    this._cacheCtx.clearRect(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);\n    this._cacheMap = {};\n    this._cacheMapCombined = {};\n    this._currentRowHeight = 0;\n    this._currentRowX = 0;\n    this._currentRowY = 0;\n    this._didWarmUp = false;\n  }\n\n  public getRasterizedGlyphCombinedChar(chars: string, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMapCombined[chars];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMapCombined[chars] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph: IRasterizedGlyph | undefined;\n    const rasterizedGlyphSetBg = rasterizedGlyphSet[bg];\n    if (rasterizedGlyphSetBg) {\n      rasterizedGlyph = rasterizedGlyphSetBg[fg];\n    }\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(chars, bg, fg);\n      if (!rasterizedGlyphSet[bg]) {\n        rasterizedGlyphSet[bg] = {};\n      }\n      rasterizedGlyphSet[bg]![fg] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Gets the glyphs texture coords, drawing the texture if it's not already\n   */\n  public getRasterizedGlyph(code: number, bg: number, fg: number): IRasterizedGlyph {\n    let rasterizedGlyphSet = this._cacheMap[code];\n    if (!rasterizedGlyphSet) {\n      rasterizedGlyphSet = {};\n      this._cacheMap[code] = rasterizedGlyphSet;\n    }\n    let rasterizedGlyph: IRasterizedGlyph | undefined;\n    const rasterizedGlyphSetBg = rasterizedGlyphSet[bg];\n    if (rasterizedGlyphSetBg) {\n      rasterizedGlyph = rasterizedGlyphSetBg[fg];\n    }\n    if (!rasterizedGlyph) {\n      rasterizedGlyph = this._drawToCache(code, bg, fg);\n      if (!rasterizedGlyphSet[bg]) {\n        rasterizedGlyphSet[bg] = {};\n      }\n      rasterizedGlyphSet[bg]![fg] = rasterizedGlyph;\n    }\n    return rasterizedGlyph;\n  }\n\n  private _getColorFromAnsiIndex(idx: number): IColor {\n    if (idx >= this._config.colors.ansi.length) {\n      throw new Error('No color found for idx ' + idx);\n    }\n    return this._config.colors.ansi[idx];\n  }\n\n  private _getBackgroundColor(bgColorMode: number, bgColor: number, inverse: boolean): IColor {\n    if (this._config.allowTransparency) {\n      // The background color might have some transparency, so we need to render it as fully\n      // transparent in the atlas. Otherwise we'd end up drawing the transparent background twice\n      // around the anti-aliased edges of the glyph, and it would look too dark.\n      return TRANSPARENT_COLOR;\n    }\n\n    switch (bgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        return this._getColorFromAnsiIndex(bgColor);\n      case Attributes.CM_RGB:\n        const arr = AttributeData.toColorRGB(bgColor);\n        // TODO: This object creation is slow\n        return {\n          rgba: bgColor << 8,\n          css: `#${toPaddedHex(arr[0])}${toPaddedHex(arr[1])}${toPaddedHex(arr[2])}`\n        };\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.foreground;\n        }\n        return this._config.colors.background;\n    }\n  }\n\n  private _getForegroundCss(bg: number, bgColorMode: number, bgColor: number, fg: number, fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): string {\n    const minimumContrastCss = this._getMinimumContrastCss(bg, bgColorMode, bgColor, fg, fgColorMode, fgColor, inverse, bold);\n    if (minimumContrastCss) {\n      return minimumContrastCss;\n    }\n\n    switch (fgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        if (this._config.drawBoldTextInBrightColors && bold && fgColor < 8) {\n          fgColor += 8;\n        }\n        return this._getColorFromAnsiIndex(fgColor).css;\n      case Attributes.CM_RGB:\n        const arr = AttributeData.toColorRGB(fgColor);\n        return channels.toCss(arr[0], arr[1], arr[2]);\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          const bg = this._config.colors.background.css;\n          if (bg.length === 9) {\n            // Remove bg alpha channel if present\n            return bg.substr(0, 7);\n          }\n          return bg;\n        }\n        return this._config.colors.foreground.css;\n    }\n  }\n\n  private _resolveBackgroundRgba(bgColorMode: number, bgColor: number, inverse: boolean): number {\n    switch (bgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        return this._getColorFromAnsiIndex(bgColor).rgba;\n      case Attributes.CM_RGB:\n        return bgColor << 8;\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.foreground.rgba;\n        }\n        return this._config.colors.background.rgba;\n    }\n  }\n\n  private _resolveForegroundRgba(fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): number {\n    switch (fgColorMode) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:\n        if (this._config.drawBoldTextInBrightColors && bold && fgColor < 8) {\n          fgColor += 8;\n        }\n        return this._getColorFromAnsiIndex(fgColor).rgba;\n      case Attributes.CM_RGB:\n        return fgColor << 8;\n      case Attributes.CM_DEFAULT:\n      default:\n        if (inverse) {\n          return this._config.colors.background.rgba;\n        }\n        return this._config.colors.foreground.rgba;\n    }\n  }\n\n  private _getMinimumContrastCss(bg: number, bgColorMode: number, bgColor: number, fg: number, fgColorMode: number, fgColor: number, inverse: boolean, bold: boolean): string | undefined {\n    if (this._config.minimumContrastRatio === 1) {\n      return undefined;\n    }\n\n    // Try get from cache first\n    const adjustedColor = this._config.colors.contrastCache.getCss(bg, fg);\n    if (adjustedColor !== undefined) {\n      return adjustedColor || undefined;\n    }\n\n    const bgRgba = this._resolveBackgroundRgba(bgColorMode, bgColor, inverse);\n    const fgRgba = this._resolveForegroundRgba(fgColorMode, fgColor, inverse, bold);\n    const result = rgba.ensureContrastRatio(bgRgba, fgRgba, this._config.minimumContrastRatio);\n\n    if (!result) {\n      this._config.colors.contrastCache.setCss(bg, fg, null);\n      return undefined;\n    }\n\n    const css = channels.toCss(\n      (result >> 24) & 0xFF,\n      (result >> 16) & 0xFF,\n      (result >> 8) & 0xFF\n    );\n    this._config.colors.contrastCache.setCss(bg, fg, css);\n\n    return css;\n  }\n\n  private _drawToCache(code: number, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(chars: string, bg: number, fg: number): IRasterizedGlyph;\n  private _drawToCache(codeOrChars: number | string, bg: number, fg: number): IRasterizedGlyph {\n    const chars = typeof codeOrChars === 'number' ? String.fromCharCode(codeOrChars) : codeOrChars;\n\n    this.hasCanvasChanged = true;\n\n    // Allow 1 cell width per character, with a minimum of 2 (CJK), plus some padding. This is used\n    // to draw the glyph to the canvas as well as to restrict the bounding box search to ensure\n    // giant ligatures (eg. =====>) don't impact overall performance.\n    const allowedWidth = this._config.scaledCharWidth * Math.max(chars.length, 2) + TMP_CANVAS_GLYPH_PADDING * 2;\n    if (this._tmpCanvas.width < allowedWidth) {\n      this._tmpCanvas.width = allowedWidth;\n    }\n    this._tmpCtx.save();\n\n    this._workAttributeData.fg = fg;\n    this._workAttributeData.bg = bg;\n\n    const invisible = !!this._workAttributeData.isInvisible();\n    if (invisible) {\n      return NULL_RASTERIZED_GLYPH;\n    }\n\n    const bold = !!this._workAttributeData.isBold();\n    const inverse = !!this._workAttributeData.isInverse();\n    const dim = !!this._workAttributeData.isDim();\n    const italic = !!this._workAttributeData.isItalic();\n    let fgColor = this._workAttributeData.getFgColor();\n    let fgColorMode = this._workAttributeData.getFgColorMode();\n    let bgColor = this._workAttributeData.getBgColor();\n    let bgColorMode = this._workAttributeData.getBgColorMode();\n    if (inverse) {\n      const temp = fgColor;\n      fgColor = bgColor;\n      bgColor = temp;\n      const temp2 = fgColorMode;\n      fgColorMode = bgColorMode;\n      bgColorMode = temp2;\n    }\n\n    // draw the background\n    const backgroundColor = this._getBackgroundColor(bgColorMode, bgColor, inverse);\n    // Use a 'copy' composite operation to clear any existing glyph out of _tmpCtxWithAlpha, regardless of\n    // transparency in backgroundColor\n    this._tmpCtx.globalCompositeOperation = 'copy';\n    this._tmpCtx.fillStyle = backgroundColor.css;\n    this._tmpCtx.fillRect(0, 0, this._tmpCanvas.width, this._tmpCanvas.height);\n    this._tmpCtx.globalCompositeOperation = 'source-over';\n\n    // draw the foreground/glyph\n    const fontWeight = bold ? this._config.fontWeightBold : this._config.fontWeight;\n    const fontStyle = italic ? 'italic' : '';\n    this._tmpCtx.font =\n      `${fontStyle} ${fontWeight} ${this._config.fontSize * this._config.devicePixelRatio}px ${this._config.fontFamily}`;\n    this._tmpCtx.textBaseline = 'ideographic';\n\n    this._tmpCtx.fillStyle = this._getForegroundCss(bg, bgColorMode, bgColor, fg, fgColorMode, fgColor, inverse, bold);\n\n    // Apply alpha to dim the character\n    if (dim) {\n      this._tmpCtx.globalAlpha = DIM_OPACITY;\n    }\n\n    // Check if the char is a powerline glyph, these will be restricted to a single cell glyph, no\n    // padding on either side that are allowed for other glyphs since they are designed to be pixel\n    // perfect but may render with \"bad\" anti-aliasing\n    let isPowerlineGlyph = false;\n    if (chars.length === 1) {\n      const code = chars.charCodeAt(0);\n      if (code >= 0xE0A0 && code <= 0xE0D6) {\n        isPowerlineGlyph = true;\n      }\n    }\n\n    // For powerline glyphs left/top padding is excluded (https://github.com/microsoft/vscode/issues/120129)\n    const padding = isPowerlineGlyph ? 0 : TMP_CANVAS_GLYPH_PADDING;\n\n    // Draw the character\n    this._tmpCtx.fillText(chars, padding, padding + this._config.scaledCharHeight);\n    this._tmpCtx.restore();\n\n    // clear the background from the character to avoid issues with drawing over the previous\n    // character if it extends past it's bounds\n    const imageData = this._tmpCtx.getImageData(\n      0, 0, this._tmpCanvas.width, this._tmpCanvas.height\n    );\n\n    // TODO: Support transparency\n    // let isEmpty = false;\n    // if (!this._config.allowTransparency) {\n    //   isEmpty = clearColor(imageData, backgroundColor);\n    // }\n\n    // Clear out the background color and determine if the glyph is empty.\n    const isEmpty = clearColor(imageData, backgroundColor);\n\n    // Handle empty glyphs\n    if (isEmpty) {\n      return NULL_RASTERIZED_GLYPH;\n    }\n\n    const rasterizedGlyph = this._findGlyphBoundingBox(imageData, this._workBoundingBox, allowedWidth, isPowerlineGlyph);\n    const clippedImageData = this._clipImageData(imageData, this._workBoundingBox);\n\n    // Check if there is enough room in the current row and go to next if needed\n    if (this._currentRowX + this._config.scaledCharWidth > TEXTURE_WIDTH) {\n      this._currentRowX = 0;\n      this._currentRowY += this._currentRowHeight;\n      this._currentRowHeight = 0;\n    }\n\n    // Record texture position\n    rasterizedGlyph.texturePosition.x = this._currentRowX;\n    rasterizedGlyph.texturePosition.y = this._currentRowY;\n    rasterizedGlyph.texturePositionClipSpace.x = this._currentRowX / TEXTURE_WIDTH;\n    rasterizedGlyph.texturePositionClipSpace.y = this._currentRowY / TEXTURE_HEIGHT;\n\n    // Update atlas current row\n    this._currentRowHeight = Math.max(this._currentRowHeight, rasterizedGlyph.size.y);\n    this._currentRowX += rasterizedGlyph.size.x;\n\n    // putImageData doesn't do any blending, so it will overwrite any existing cache entry for us\n    this._cacheCtx.putImageData(clippedImageData, rasterizedGlyph.texturePosition.x, rasterizedGlyph.texturePosition.y);\n\n    return rasterizedGlyph;\n  }\n\n  /**\n   * Given an ImageData object, find the bounding box of the non-transparent\n   * portion of the texture and return an IRasterizedGlyph with these\n   * dimensions.\n   * @param imageData The image data to read.\n   * @param boundingBox An IBoundingBox to put the clipped bounding box values.\n   */\n  private _findGlyphBoundingBox(imageData: ImageData, boundingBox: IBoundingBox, allowedWidth: number, restrictedGlyph: boolean): IRasterizedGlyph {\n    boundingBox.top = 0;\n    const height = restrictedGlyph ? this._config.scaledCharHeight : this._tmpCanvas.height;\n    const width = restrictedGlyph ? this._config.scaledCharWidth : allowedWidth;\n    let found = false;\n    for (let y = 0; y < height; y++) {\n      for (let x = 0; x < width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.top = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.left = 0;\n    found = false;\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.left = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.right = width;\n    found = false;\n    for (let x = width - 1; x >= 0; x--) {\n      for (let y = 0; y < height; y++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.right = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    boundingBox.bottom = height;\n    found = false;\n    for (let y = height - 1; y >= 0; y--) {\n      for (let x = 0; x < width; x++) {\n        const alphaOffset = y * this._tmpCanvas.width * 4 + x * 4 + 3;\n        if (imageData.data[alphaOffset] !== 0) {\n          boundingBox.bottom = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) {\n        break;\n      }\n    }\n    return {\n      texturePosition: { x: 0, y: 0 },\n      texturePositionClipSpace: { x: 0, y: 0 },\n      size: {\n        x: boundingBox.right - boundingBox.left + 1,\n        y: boundingBox.bottom - boundingBox.top + 1\n      },\n      sizeClipSpace: {\n        x: (boundingBox.right - boundingBox.left + 1) / TEXTURE_WIDTH,\n        y: (boundingBox.bottom - boundingBox.top + 1) / TEXTURE_HEIGHT\n      },\n      offset: {\n        x: -boundingBox.left + (restrictedGlyph ? 0 : TMP_CANVAS_GLYPH_PADDING),\n        y: -boundingBox.top + (restrictedGlyph ? 0 : TMP_CANVAS_GLYPH_PADDING)\n      }\n    };\n  }\n\n  private _clipImageData(imageData: ImageData, boundingBox: IBoundingBox): ImageData {\n    const width = boundingBox.right - boundingBox.left + 1;\n    const height = boundingBox.bottom - boundingBox.top + 1;\n    const clippedData = new Uint8ClampedArray(width * height * 4);\n    for (let y = boundingBox.top; y <= boundingBox.bottom; y++) {\n      for (let x = boundingBox.left; x <= boundingBox.right; x++) {\n        const oldOffset = y * this._tmpCanvas.width * 4 + x * 4;\n        const newOffset = (y - boundingBox.top) * width * 4 + (x - boundingBox.left) * 4;\n        clippedData[newOffset] = imageData.data[oldOffset];\n        clippedData[newOffset + 1] = imageData.data[oldOffset + 1];\n        clippedData[newOffset + 2] = imageData.data[oldOffset + 2];\n        clippedData[newOffset + 3] = imageData.data[oldOffset + 3];\n      }\n    }\n    return new ImageData(clippedData, width, height);\n  }\n}\n\n/**\n * Makes a partiicular rgb color in an ImageData completely transparent.\n * @returns True if the result is \"empty\", meaning all pixels are fully transparent.\n */\nfunction clearColor(imageData: ImageData, color: IColor): boolean {\n  let isEmpty = true;\n  const r = color.rgba >>> 24;\n  const g = color.rgba >>> 16 & 0xFF;\n  const b = color.rgba >>> 8 & 0xFF;\n  for (let offset = 0; offset < imageData.data.length; offset += 4) {\n    if (imageData.data[offset] === r &&\n        imageData.data[offset + 1] === g &&\n        imageData.data[offset + 2] === b) {\n      imageData.data[offset + 3] = 0;\n    } else {\n      isEmpty = false;\n    }\n  }\n  return isEmpty;\n}\n\nfunction toPaddedHex(c: number): string {\n  const s = c.toString(16);\n  return s.length < 2 ? '0' + s : s;\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IRenderLayer } from './Types';\nimport { acquireCharAtlas } from '../atlas/CharAtlasCache';\nimport { Terminal } from 'xterm';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { WebglCharAtlas } from 'atlas/WebglCharAtlas';\nimport { throwIfFalsy } from '../WebglUtils';\n\nexport abstract class BaseRenderLayer implements IRenderLayer {\n  private _canvas: HTMLCanvasElement;\n  protected _ctx!: CanvasRenderingContext2D;\n  private _scaledCharWidth: number = 0;\n  private _scaledCharHeight: number = 0;\n  private _scaledCellWidth: number = 0;\n  private _scaledCellHeight: number = 0;\n  private _scaledCharLeft: number = 0;\n  private _scaledCharTop: number = 0;\n\n  protected _charAtlas: WebglCharAtlas | undefined;\n\n  constructor(\n    private _container: HTMLElement,\n    id: string,\n    zIndex: number,\n    private _alpha: boolean,\n    protected _colors: IColorSet\n  ) {\n    this._canvas = document.createElement('canvas');\n    this._canvas.classList.add(`xterm-${id}-layer`);\n    this._canvas.style.zIndex = zIndex.toString();\n    this._initCanvas();\n    this._container.appendChild(this._canvas);\n  }\n\n  public dispose(): void {\n    this._container.removeChild(this._canvas);\n    if (this._charAtlas) {\n      this._charAtlas.dispose();\n    }\n  }\n\n  private _initCanvas(): void {\n    this._ctx = throwIfFalsy(this._canvas.getContext('2d', { alpha: this._alpha }));\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {}\n  public onBlur(terminal: Terminal): void {}\n  public onFocus(terminal: Terminal): void {}\n  public onCursorMove(terminal: Terminal): void {}\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {}\n  public onSelectionChanged(terminal: Terminal, start: [number, number] | undefined, end: [number, number] | undefined, columnSelectMode: boolean = false): void {}\n\n  public setColors(terminal: Terminal, colorSet: IColorSet): void {\n    this._refreshCharAtlas(terminal, colorSet);\n  }\n\n  protected _setTransparency(terminal: Terminal, alpha: boolean): void {\n    // Do nothing when alpha doesn't change\n    if (alpha === this._alpha) {\n      return;\n    }\n\n    // Create new canvas and replace old one\n    const oldCanvas = this._canvas;\n    this._alpha = alpha;\n    // Cloning preserves properties\n    this._canvas = this._canvas.cloneNode() as HTMLCanvasElement;\n    this._initCanvas();\n    this._container.replaceChild(this._canvas, oldCanvas);\n\n    // Regenerate char atlas and force a full redraw\n    this._refreshCharAtlas(terminal, this._colors);\n    this.onGridChanged(terminal, 0, terminal.rows - 1);\n  }\n\n  /**\n   * Refreshes the char atlas, aquiring a new one if necessary.\n   * @param terminal The terminal.\n   * @param colorSet The color set to use for the char atlas.\n   */\n  private _refreshCharAtlas(terminal: Terminal, colorSet: IColorSet): void {\n    if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {\n      return;\n    }\n    this._charAtlas = acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);\n    this._charAtlas.warmUp();\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    this._scaledCellWidth = dim.scaledCellWidth;\n    this._scaledCellHeight = dim.scaledCellHeight;\n    this._scaledCharWidth = dim.scaledCharWidth;\n    this._scaledCharHeight = dim.scaledCharHeight;\n    this._scaledCharLeft = dim.scaledCharLeft;\n    this._scaledCharTop = dim.scaledCharTop;\n    this._canvas.width = dim.scaledCanvasWidth;\n    this._canvas.height = dim.scaledCanvasHeight;\n    this._canvas.style.width = `${dim.canvasWidth}px`;\n    this._canvas.style.height = `${dim.canvasHeight}px`;\n\n    // Draw the background if this is an opaque layer\n    if (!this._alpha) {\n      this._clearAll();\n    }\n\n    this._refreshCharAtlas(terminal, this._colors);\n  }\n\n  public abstract reset(terminal: Terminal): void;\n\n  /**\n   * Fills 1+ cells completely. This uses the existing fillStyle on the context.\n   * @param x The column to start at.\n   * @param y The row to start at\n   * @param width The number of columns to fill.\n   * @param height The number of rows to fill.\n   */\n  protected _fillCells(x: number, y: number, width: number, height: number): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      y * this._scaledCellHeight,\n      width * this._scaledCellWidth,\n      height * this._scaledCellHeight);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the bottom of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillBottomLineAtCells(x: number, y: number, width: number = 1): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1 /* Ensure it's drawn within the cell */,\n      width * this._scaledCellWidth,\n      window.devicePixelRatio);\n  }\n\n  /**\n   * Fills a 1px line (2px on HDPI) at the left of the cell. This uses the\n   * existing fillStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _fillLeftLineAtCell(x: number, y: number, width: number): void {\n    this._ctx.fillRect(\n      x * this._scaledCellWidth,\n      y * this._scaledCellHeight,\n      window.devicePixelRatio * width,\n      this._scaledCellHeight);\n  }\n\n  /**\n   * Strokes a 1px rectangle (2px on HDPI) around a cell. This uses the existing\n   * strokeStyle on the context.\n   * @param x The column to fill.\n   * @param y The row to fill.\n   */\n  protected _strokeRectAtCell(x: number, y: number, width: number, height: number): void {\n    this._ctx.lineWidth = window.devicePixelRatio;\n    this._ctx.strokeRect(\n      x * this._scaledCellWidth + window.devicePixelRatio / 2,\n      y * this._scaledCellHeight + (window.devicePixelRatio / 2),\n      width * this._scaledCellWidth - window.devicePixelRatio,\n      (height * this._scaledCellHeight) - window.devicePixelRatio);\n  }\n\n  /**\n   * Clears the entire canvas.\n   */\n  protected _clearAll(): void {\n    if (this._alpha) {\n      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }\n\n  /**\n   * Clears 1+ cells completely.\n   * @param x The column to start at.\n   * @param y The row to start at.\n   * @param width The number of columns to clear.\n   * @param height The number of rows to clear.\n   */\n  protected _clearCells(x: number, y: number, width: number, height: number): void {\n    if (this._alpha) {\n      this._ctx.clearRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        width * this._scaledCellWidth,\n        height * this._scaledCellHeight);\n    } else {\n      this._ctx.fillStyle = this._colors.background.css;\n      this._ctx.fillRect(\n        x * this._scaledCellWidth,\n        y * this._scaledCellHeight,\n        width * this._scaledCellWidth,\n        height * this._scaledCellHeight);\n    }\n  }\n\n  /**\n   * Draws a truecolor character at the cell. The character will be clipped to\n   * ensure that it fits with the cell, including the cell to the right if it's\n   * a wide character. This uses the existing fillStyle on the context.\n   * @param terminal The terminal.\n   * @param cell The cell data for the character to draw.\n   * @param x The column to draw at.\n   * @param y The row to draw at.\n   * @param color The color of the character.\n   */\n  protected _fillCharTrueColor(terminal: Terminal, cell: CellData, x: number, y: number): void {\n    this._ctx.font = this._getFont(terminal, false, false);\n    this._ctx.textBaseline = 'ideographic';\n    this._clipRow(terminal, y);\n    this._ctx.fillText(\n      cell.getChars(),\n      x * this._scaledCellWidth + this._scaledCharLeft,\n      y * this._scaledCellHeight + this._scaledCharTop + this._scaledCharHeight);\n  }\n\n  /**\n   * Clips a row to ensure no pixels will be drawn outside the cells in the row.\n   * @param terminal The terminal.\n   * @param y The row to clip.\n   */\n  private _clipRow(terminal: Terminal, y: number): void {\n    this._ctx.beginPath();\n    this._ctx.rect(\n      0,\n      y * this._scaledCellHeight,\n      terminal.cols * this._scaledCellWidth,\n      this._scaledCellHeight);\n    this._ctx.clip();\n  }\n\n  /**\n   * Gets the current font.\n   * @param terminal The terminal.\n   * @param isBold If we should use the bold fontWeight.\n   */\n  protected _getFont(terminal: Terminal, isBold: boolean, isItalic: boolean): string {\n    const fontWeight = isBold ? terminal.getOption('fontWeightBold') : terminal.getOption('fontWeight');\n    const fontStyle = isItalic ? 'italic' : '';\n\n    return `${fontStyle} ${fontWeight} ${terminal.getOption('fontSize') * window.devicePixelRatio}px ${terminal.getOption('fontFamily')}`;\n  }\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { ICellData } from 'common/Types';\nimport { CellData } from 'common/buffer/CellData';\nimport { IColorSet } from 'browser/Types';\nimport { IRenderDimensions, IRequestRedrawEvent } from 'browser/renderer/Types';\nimport { IEventEmitter } from 'common/EventEmitter';\n\ninterface ICursorState {\n  x: number;\n  y: number;\n  isFocused: boolean;\n  style: string;\n  width: number;\n}\n\n/**\n * The time between cursor blinks.\n */\nconst BLINK_INTERVAL = 600;\n\nexport class CursorRenderLayer extends BaseRenderLayer {\n  private _state: ICursorState;\n  private _cursorRenderers: {[key: string]: (terminal: Terminal, x: number, y: number, cell: ICellData) => void};\n  private _cursorBlinkStateManager: CursorBlinkStateManager | undefined;\n  private _cell: ICellData = new CellData();\n\n  constructor(\n    container: HTMLElement,\n    zIndex: number,\n    colors: IColorSet,\n    private _onRequestRefreshRowsEvent: IEventEmitter<IRequestRedrawEvent>\n  ) {\n    super(container, 'cursor', zIndex, true, colors);\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n    this._cursorRenderers = {\n      'bar': this._renderBarCursor.bind(this),\n      'block': this._renderBlockCursor.bind(this),\n      'underline': this._renderUnderlineCursor.bind(this)\n    };\n    // TODO: Consider initial options? Maybe onOptionsChanged should be called at the end of open?\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = {\n      x: 0,\n      y: 0,\n      isFocused: false,\n      style: '',\n      width: 0\n    };\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCursor();\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.dispose();\n      this.onOptionsChanged(terminal);\n    }\n  }\n\n  public onBlur(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.pause();\n    }\n    this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n  }\n\n  public onFocus(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.resume(terminal);\n    } else {\n      this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n    }\n  }\n\n  public onOptionsChanged(terminal: Terminal): void {\n    if (terminal.getOption('cursorBlink')) {\n      if (!this._cursorBlinkStateManager) {\n        this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, () => {\n          this._render(terminal, true);\n        });\n      }\n    } else {\n      this._cursorBlinkStateManager?.dispose();\n      this._cursorBlinkStateManager = undefined;\n    }\n    // Request a refresh from the terminal as management of rendering is being\n    // moved back to the terminal\n    this._onRequestRefreshRowsEvent.fire({ start: terminal.buffer.active.cursorY, end: terminal.buffer.active.cursorY });\n  }\n\n  public onCursorMove(terminal: Terminal): void {\n    if (this._cursorBlinkStateManager) {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  public onGridChanged(terminal: Terminal, startRow: number, endRow: number): void {\n    if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {\n      this._render(terminal, false);\n    } else {\n      this._cursorBlinkStateManager.restartBlinkAnimation(terminal);\n    }\n  }\n\n  private _render(terminal: Terminal, triggeredByAnimationFrame: boolean): void {\n    // Don't draw the cursor if it's hidden\n    // TODO: Need to expose API for this\n    if (!(terminal as any)._core._coreService.isCursorInitialized || (terminal as any)._core._coreService.isCursorHidden) {\n      this._clearCursor();\n      return;\n    }\n\n    const cursorY = terminal.buffer.active.baseY + terminal.buffer.active.cursorY;\n    const viewportRelativeCursorY = cursorY - terminal.buffer.active.viewportY;\n\n    // in case cursor.x == cols adjust visual cursor to cols - 1\n    const cursorX = Math.min(terminal.buffer.active.cursorX, terminal.cols - 1);\n\n    // Don't draw the cursor if it's off-screen\n    if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {\n      this._clearCursor();\n      return;\n    }\n\n    // TODO: Need fast buffer API for loading cell\n    (terminal as any)._core.buffer.lines.get(cursorY).loadCell(cursorX, this._cell);\n    if (this._cell.content === undefined) {\n      return;\n    }\n\n    if (!isTerminalFocused(terminal)) {\n      this._clearCursor();\n      this._ctx.save();\n      this._ctx.fillStyle = this._colors.cursor.css;\n      const cursorStyle = terminal.getOption('cursorStyle');\n      if (cursorStyle && cursorStyle !== 'block') {\n        this._cursorRenderers[cursorStyle](terminal, cursorX, viewportRelativeCursorY, this._cell);\n      } else {\n        this._renderBlurCursor(terminal, cursorX, viewportRelativeCursorY, this._cell);\n      }\n      this._ctx.restore();\n      this._state.x = cursorX;\n      this._state.y = viewportRelativeCursorY;\n      this._state.isFocused = false;\n      this._state.style = cursorStyle;\n      this._state.width = this._cell.getWidth();\n      return;\n    }\n\n    // Don't draw the cursor if it's blinking\n    if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {\n      this._clearCursor();\n      return;\n    }\n\n    if (this._state) {\n      // The cursor is already in the correct spot, don't redraw\n      if (this._state.x === cursorX &&\n          this._state.y === viewportRelativeCursorY &&\n          this._state.isFocused === isTerminalFocused(terminal) &&\n          this._state.style === terminal.getOption('cursorStyle') &&\n          this._state.width === this._cell.getWidth()) {\n        return;\n      }\n      this._clearCursor();\n    }\n\n    this._ctx.save();\n    this._cursorRenderers[terminal.getOption('cursorStyle') || 'block'](terminal, cursorX, viewportRelativeCursorY, this._cell);\n    this._ctx.restore();\n\n    this._state.x = cursorX;\n    this._state.y = viewportRelativeCursorY;\n    this._state.isFocused = false;\n    this._state.style = terminal.getOption('cursorStyle');\n    this._state.width = this._cell.getWidth();\n  }\n\n  private _clearCursor(): void {\n    if (this._state) {\n      this._clearCells(this._state.x, this._state.y, this._state.width, 1);\n      this._state = {\n        x: 0,\n        y: 0,\n        isFocused: false,\n        style: '',\n        width: 0\n      };\n    }\n  }\n\n  private _renderBarCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillLeftLineAtCell(x, y, terminal.getOption('cursorWidth'));\n    this._ctx.restore();\n  }\n\n  private _renderBlockCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillCells(x, y, cell.getWidth(), 1);\n    this._ctx.fillStyle = this._colors.cursorAccent.css;\n    this._fillCharTrueColor(terminal, cell, x, y);\n    this._ctx.restore();\n  }\n\n  private _renderUnderlineCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.fillStyle = this._colors.cursor.css;\n    this._fillBottomLineAtCells(x, y);\n    this._ctx.restore();\n  }\n\n  private _renderBlurCursor(terminal: Terminal, x: number, y: number, cell: ICellData): void {\n    this._ctx.save();\n    this._ctx.strokeStyle = this._colors.cursor.css;\n    this._strokeRectAtCell(x, y, cell.getWidth(), 1);\n    this._ctx.restore();\n  }\n}\n\nclass CursorBlinkStateManager {\n  public isCursorVisible: boolean;\n\n  private _animationFrame: number | undefined;\n  private _blinkStartTimeout: number | undefined;\n  private _blinkInterval: number | undefined;\n\n  /**\n   * The time at which the animation frame was restarted, this is used on the\n   * next render to restart the timers so they don't need to restart the timers\n   * multiple times over a short period.\n   */\n  private _animationTimeRestarted: number | undefined;\n\n  constructor(\n    terminal: Terminal,\n    private _renderCallback: () => void\n  ) {\n    this.isCursorVisible = true;\n    if (isTerminalFocused(terminal)) {\n      this._restartInterval();\n    }\n  }\n\n  public get isPaused(): boolean { return !(this._blinkStartTimeout || this._blinkInterval); }\n\n  public dispose(): void {\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public restartBlinkAnimation(terminal: Terminal): void {\n    if (this.isPaused) {\n      return;\n    }\n    // Save a timestamp so that the restart can be done on the next interval\n    this._animationTimeRestarted = Date.now();\n    // Force a cursor render to ensure it's visible and in the correct position\n    this.isCursorVisible = true;\n    if (!this._animationFrame) {\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n    }\n  }\n\n  private _restartInterval(timeToStart: number = BLINK_INTERVAL): void {\n    // Clear any existing interval\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n    }\n\n    // Setup the initial timeout which will hide the cursor, this is done before\n    // the regular interval is setup in order to support restarting the blink\n    // animation in a lightweight way (without thrashing clearInterval and\n    // setInterval).\n    this._blinkStartTimeout = window.setTimeout(() => {\n      // Check if another animation restart was requested while this was being\n      // started\n      if (this._animationTimeRestarted) {\n        const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n        this._animationTimeRestarted = undefined;\n        if (time > 0) {\n          this._restartInterval(time);\n          return;\n        }\n      }\n\n      // Hide the cursor\n      this.isCursorVisible = false;\n      this._animationFrame = window.requestAnimationFrame(() => {\n        this._renderCallback();\n        this._animationFrame = undefined;\n      });\n\n      // Setup the blink interval\n      this._blinkInterval = window.setInterval(() => {\n        // Adjust the animation time if it was restarted\n        if (this._animationTimeRestarted) {\n          // calc time diff\n          // Make restart interval do a setTimeout initially?\n          const time = BLINK_INTERVAL - (Date.now() - this._animationTimeRestarted);\n          this._animationTimeRestarted = undefined;\n          this._restartInterval(time);\n          return;\n        }\n\n        // Invert visibility and render\n        this.isCursorVisible = !this.isCursorVisible;\n        this._animationFrame = window.requestAnimationFrame(() => {\n          this._renderCallback();\n          this._animationFrame = undefined;\n        });\n      }, BLINK_INTERVAL);\n    }, timeToStart);\n  }\n\n  public pause(): void {\n    this.isCursorVisible = true;\n    if (this._blinkInterval) {\n      window.clearInterval(this._blinkInterval);\n      this._blinkInterval = undefined;\n    }\n    if (this._blinkStartTimeout) {\n      window.clearTimeout(this._blinkStartTimeout);\n      this._blinkStartTimeout = undefined;\n    }\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n      this._animationFrame = undefined;\n    }\n  }\n\n  public resume(terminal: Terminal): void {\n    // Clear out any existing timers just in case\n    this.pause();\n\n    this._animationTimeRestarted = undefined;\n    this._restartInterval();\n    this.restartBlinkAnimation(terminal);\n  }\n}\n\nfunction isTerminalFocused(terminal: Terminal): boolean {\n  return document.activeElement === terminal.textarea && document.hasFocus();\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal } from 'xterm';\nimport { BaseRenderLayer } from './BaseRenderLayer';\nimport { INVERTED_DEFAULT_COLOR } from 'browser/renderer/atlas/Constants';\nimport { is256Color } from '../atlas/CharAtlasUtils';\nimport { ITerminal, IColorSet, ILinkifierEvent } from 'browser/Types';\nimport { IRenderDimensions } from 'browser/renderer/Types';\n\nexport class LinkRenderLayer extends BaseRenderLayer {\n  private _state: ILinkifierEvent | undefined;\n\n  constructor(container: HTMLElement, zIndex: number, colors: IColorSet, terminal: ITerminal) {\n    super(container, 'link', zIndex, true, colors);\n    terminal.linkifier.onShowLinkUnderline(e => this._onShowLinkUnderline(e));\n    terminal.linkifier.onHideLinkUnderline(e => this._onHideLinkUnderline(e));\n\n    terminal.linkifier2.onShowLinkUnderline(e => this._onShowLinkUnderline(e));\n    terminal.linkifier2.onHideLinkUnderline(e => this._onHideLinkUnderline(e));\n  }\n\n  public resize(terminal: Terminal, dim: IRenderDimensions): void {\n    super.resize(terminal, dim);\n    // Resizing the canvas discards the contents of the canvas so clear state\n    this._state = undefined;\n  }\n\n  public reset(terminal: Terminal): void {\n    this._clearCurrentLink();\n  }\n\n  private _clearCurrentLink(): void {\n    if (this._state) {\n      this._clearCells(this._state.x1, this._state.y1, this._state.cols - this._state.x1, 1);\n      const middleRowCount = this._state.y2 - this._state.y1 - 1;\n      if (middleRowCount > 0) {\n        this._clearCells(0, this._state.y1 + 1, this._state.cols, middleRowCount);\n      }\n      this._clearCells(0, this._state.y2, this._state.x2, 1);\n      this._state = undefined;\n    }\n  }\n\n  private _onShowLinkUnderline(e: ILinkifierEvent): void {\n    if (e.fg === INVERTED_DEFAULT_COLOR) {\n      this._ctx.fillStyle = this._colors.background.css;\n    } else if (e.fg !== undefined && is256Color(e.fg)) {\n      // 256 color support\n      this._ctx.fillStyle = this._colors.ansi[e.fg!].css;\n    } else {\n      this._ctx.fillStyle = this._colors.foreground.css;\n    }\n\n    if (e.y1 === e.y2) {\n      // Single line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.x2 - e.x1);\n    } else {\n      // Multi-line link\n      this._fillBottomLineAtCells(e.x1, e.y1, e.cols - e.x1);\n      for (let y = e.y1 + 1; y < e.y2; y++) {\n        this._fillBottomLineAtCells(0, y, e.cols);\n      }\n      this._fillBottomLineAtCells(0, e.y2, e.x2);\n    }\n    this._state = e;\n  }\n\n  private _onHideLinkUnderline(e: ILinkifierEvent): void {\n    this._clearCurrentLink();\n  }\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IColor } from 'browser/Types';\n\n/**\n * Helper functions where the source type is \"channels\" (individual color channels as numbers).\n */\nexport namespace channels {\n  export function toCss(r: number, g: number, b: number, a?: number): string {\n    if (a !== undefined) {\n      return `#${toPaddedHex(r)}${toPaddedHex(g)}${toPaddedHex(b)}${toPaddedHex(a)}`;\n    }\n    return `#${toPaddedHex(r)}${toPaddedHex(g)}${toPaddedHex(b)}`;\n  }\n\n  export function toRgba(r: number, g: number, b: number, a: number = 0xFF): number {\n    // >>> 0 forces an unsigned int\n    return (r << 24 | g << 16 | b << 8 | a) >>> 0;\n  }\n}\n\n/**\n * Helper functions where the source type is `IColor`.\n */\nexport namespace color {\n  export function blend(bg: IColor, fg: IColor): IColor {\n    const a = (fg.rgba & 0xFF) / 255;\n    if (a === 1) {\n      return {\n        css: fg.css,\n        rgba: fg.rgba\n      };\n    }\n    const fgR = (fg.rgba >> 24) & 0xFF;\n    const fgG = (fg.rgba >> 16) & 0xFF;\n    const fgB = (fg.rgba >> 8) & 0xFF;\n    const bgR = (bg.rgba >> 24) & 0xFF;\n    const bgG = (bg.rgba >> 16) & 0xFF;\n    const bgB = (bg.rgba >> 8) & 0xFF;\n    const r = bgR + Math.round((fgR - bgR) * a);\n    const g = bgG + Math.round((fgG - bgG) * a);\n    const b = bgB + Math.round((fgB - bgB) * a);\n    const css = channels.toCss(r, g, b);\n    const rgba = channels.toRgba(r, g, b);\n    return { css, rgba };\n  }\n\n  export function isOpaque(color: IColor): boolean {\n    return (color.rgba & 0xFF) === 0xFF;\n  }\n\n  export function ensureContrastRatio(bg: IColor, fg: IColor, ratio: number): IColor | undefined {\n    const result = rgba.ensureContrastRatio(bg.rgba, fg.rgba, ratio);\n    if (!result) {\n      return undefined;\n    }\n    return rgba.toColor(\n      (result >> 24 & 0xFF),\n      (result >> 16 & 0xFF),\n      (result >> 8  & 0xFF)\n    );\n  }\n\n  export function opaque(color: IColor): IColor {\n    const rgbaColor = (color.rgba | 0xFF) >>> 0;\n    const [r, g, b] = rgba.toChannels(rgbaColor);\n    return {\n      css: channels.toCss(r, g, b),\n      rgba: rgbaColor\n    };\n  }\n\n  export function opacity(color: IColor, opacity: number): IColor {\n    const a = Math.round(opacity * 0xFF);\n    const [r, g, b] = rgba.toChannels(color.rgba);\n    return {\n      css: channels.toCss(r, g, b, a),\n      rgba: channels.toRgba(r, g, b, a)\n    };\n  }\n}\n\n/**\n * Helper functions where the source type is \"css\" (string: '#rgb', '#rgba', '#rrggbb', '#rrggbbaa').\n */\nexport namespace css {\n  export function toColor(css: string): IColor {\n    switch (css.length) {\n      case 7: // #rrggbb\n        return {\n          css,\n          rgba: (parseInt(css.slice(1), 16) << 8 | 0xFF) >>> 0\n        };\n      case 9: // #rrggbbaa\n        return {\n          css,\n          rgba: parseInt(css.slice(1), 16) >>> 0\n        };\n    }\n    throw new Error('css.toColor: Unsupported css format');\n  }\n}\n\n/**\n * Helper functions where the source type is \"rgb\" (number: 0xrrggbb).\n */\nexport namespace rgb {\n  /**\n   * Gets the relative luminance of an RGB color, this is useful in determining the contrast ratio\n   * between two colors.\n   * @param rgb The color to use.\n   * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef\n   */\n  export function relativeLuminance(rgb: number): number {\n    return relativeLuminance2(\n      (rgb >> 16) & 0xFF,\n      (rgb >> 8 ) & 0xFF,\n      (rgb      ) & 0xFF);\n  }\n\n  /**\n   * Gets the relative luminance of an RGB color, this is useful in determining the contrast ratio\n   * between two colors.\n   * @param r The red channel (0x00 to 0xFF).\n   * @param g The green channel (0x00 to 0xFF).\n   * @param b The blue channel (0x00 to 0xFF).\n   * @see https://www.w3.org/TR/WCAG20/#relativeluminancedef\n   */\n  export function relativeLuminance2(r: number, g: number, b: number): number {\n    const rs = r / 255;\n    const gs = g / 255;\n    const bs = b / 255;\n    const rr = rs <= 0.03928 ? rs / 12.92 : Math.pow((rs + 0.055) / 1.055, 2.4);\n    const rg = gs <= 0.03928 ? gs / 12.92 : Math.pow((gs + 0.055) / 1.055, 2.4);\n    const rb = bs <= 0.03928 ? bs / 12.92 : Math.pow((bs + 0.055) / 1.055, 2.4);\n    return rr * 0.2126 + rg * 0.7152 + rb * 0.0722;\n  }\n}\n\n/**\n * Helper functions where the source type is \"rgba\" (number: 0xrrggbbaa).\n */\nexport namespace rgba {\n  export function ensureContrastRatio(bgRgba: number, fgRgba: number, ratio: number): number | undefined {\n    const bgL = rgb.relativeLuminance(bgRgba >> 8);\n    const fgL = rgb.relativeLuminance(fgRgba >> 8);\n    const cr = contrastRatio(bgL, fgL);\n    if (cr < ratio) {\n      if (fgL < bgL) {\n        return reduceLuminance(bgRgba, fgRgba, ratio);\n      }\n      return increaseLuminance(bgRgba, fgRgba, ratio);\n    }\n    return undefined;\n  }\n\n  export function reduceLuminance(bgRgba: number, fgRgba: number, ratio: number): number {\n    // This is a naive but fast approach to reducing luminance as converting to\n    // HSL and back is expensive\n    const bgR = (bgRgba >> 24) & 0xFF;\n    const bgG = (bgRgba >> 16) & 0xFF;\n    const bgB = (bgRgba >>  8) & 0xFF;\n    let fgR = (fgRgba >> 24) & 0xFF;\n    let fgG = (fgRgba >> 16) & 0xFF;\n    let fgB = (fgRgba >>  8) & 0xFF;\n    let cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    while (cr < ratio && (fgR > 0 || fgG > 0 || fgB > 0)) {\n      // Reduce by 10% until the ratio is hit\n      fgR -= Math.max(0, Math.ceil(fgR * 0.1));\n      fgG -= Math.max(0, Math.ceil(fgG * 0.1));\n      fgB -= Math.max(0, Math.ceil(fgB * 0.1));\n      cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    }\n    return (fgR << 24 | fgG << 16 | fgB << 8 | 0xFF) >>> 0;\n  }\n\n  export function increaseLuminance(bgRgba: number, fgRgba: number, ratio: number): number {\n    // This is a naive but fast approach to increasing luminance as converting to\n    // HSL and back is expensive\n    const bgR = (bgRgba >> 24) & 0xFF;\n    const bgG = (bgRgba >> 16) & 0xFF;\n    const bgB = (bgRgba >>  8) & 0xFF;\n    let fgR = (fgRgba >> 24) & 0xFF;\n    let fgG = (fgRgba >> 16) & 0xFF;\n    let fgB = (fgRgba >>  8) & 0xFF;\n    let cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    while (cr < ratio && (fgR < 0xFF || fgG < 0xFF || fgB < 0xFF)) {\n      // Increase by 10% until the ratio is hit\n      fgR = Math.min(0xFF, fgR + Math.ceil((255 - fgR) * 0.1));\n      fgG = Math.min(0xFF, fgG + Math.ceil((255 - fgG) * 0.1));\n      fgB = Math.min(0xFF, fgB + Math.ceil((255 - fgB) * 0.1));\n      cr = contrastRatio(rgb.relativeLuminance2(fgR, fgB, fgG), rgb.relativeLuminance2(bgR, bgG, bgB));\n    }\n    return (fgR << 24 | fgG << 16 | fgB << 8 | 0xFF) >>> 0;\n  }\n\n  export function toChannels(value: number): [number, number, number, number] {\n    return [(value >> 24) & 0xFF, (value >> 16) & 0xFF, (value >> 8) & 0xFF, value & 0xFF];\n  }\n\n  export function toColor(r: number, g: number, b: number): IColor {\n    return {\n      css: channels.toCss(r, g, b),\n      rgba: channels.toRgba(r, g, b)\n    };\n  }\n}\n\nexport function toPaddedHex(c: number): string {\n  const s = c.toString(16);\n  return s.length < 2 ? '0' + s : s;\n}\n\n/**\n * Gets the contrast ratio between two relative luminance values.\n * @param l1 The first relative luminance.\n * @param l2 The first relative luminance.\n * @see https://www.w3.org/TR/WCAG20/#contrast-ratiodef\n */\nexport function contrastRatio(l1: number, l2: number): number {\n  if (l1 < l2) {\n    return (l2 + 0.05) / (l1 + 0.05);\n  }\n  return (l1 + 0.05) / (l2 + 0.05);\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * Adds a disposable listener to a node in the DOM, returning the disposable.\n * @param type The event type.\n * @param handler The handler for the listener.\n */\nexport function addDisposableDomListener(\n  node: Element | Window | Document,\n  type: string,\n  handler: (e: any) => void,\n  options?: boolean | AddEventListenerOptions\n): IDisposable {\n  node.addEventListener(type, handler, options);\n  let disposed = false;\n  return {\n    dispose: () => {\n      if (disposed) {\n        return;\n      }\n      disposed = true;\n      node.removeEventListener(type, handler, options);\n    }\n  };\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const INVERTED_DEFAULT_COLOR = 257;\nexport const DIM_OPACITY = 0.5;\n\nexport const CHAR_ATLAS_CELL_SPACING = 1;\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\ninterface IListener<T, U = void> {\n  (arg1: T, arg2: U): void;\n}\n\nexport interface IEvent<T, U = void> {\n  (listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IEventEmitter<T, U = void> {\n  event: IEvent<T, U>;\n  fire(arg1: T, arg2: U): void;\n  dispose(): void;\n}\n\nexport class EventEmitter<T, U = void> implements IEventEmitter<T, U> {\n  private _listeners: IListener<T, U>[] = [];\n  private _event?: IEvent<T, U>;\n  private _disposed: boolean = false;\n\n  public get event(): IEvent<T, U> {\n    if (!this._event) {\n      this._event = (listener: (arg1: T, arg2: U) => any) => {\n        this._listeners.push(listener);\n        const disposable = {\n          dispose: () => {\n            if (!this._disposed) {\n              for (let i = 0; i < this._listeners.length; i++) {\n                if (this._listeners[i] === listener) {\n                  this._listeners.splice(i, 1);\n                  return;\n                }\n              }\n            }\n          }\n        };\n        return disposable;\n      };\n    }\n    return this._event;\n  }\n\n  public fire(arg1: T, arg2: U): void {\n    const queue: IListener<T, U>[] = [];\n    for (let i = 0; i < this._listeners.length; i++) {\n      queue.push(this._listeners[i]);\n    }\n    for (let i = 0; i < queue.length; i++) {\n      queue[i].call(undefined, arg1, arg2);\n    }\n  }\n\n  public dispose(): void {\n    if (this._listeners) {\n      this._listeners.length = 0;\n    }\n    this._disposed = true;\n  }\n}\n\nexport function forwardEvent<T>(from: IEvent<T>, to: IEventEmitter<T>): IDisposable {\n  return from(e => to.fire(e));\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * A base class that can be extended to provide convenience methods for managing the lifecycle of an\n * object and its components.\n */\nexport abstract class Disposable implements IDisposable {\n  protected _disposables: IDisposable[] = [];\n  protected _isDisposed: boolean = false;\n\n  constructor() {\n  }\n\n  /**\n   * Disposes the object, triggering the `dispose` method on all registered IDisposables.\n   */\n  public dispose(): void {\n    this._isDisposed = true;\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n    this._disposables.length = 0;\n  }\n\n  /**\n   * Registers a disposable object.\n   * @param d The disposable to register.\n   * @returns The disposable.\n   */\n  public register<T extends IDisposable>(d: T): T {\n    this._disposables.push(d);\n    return d;\n  }\n\n  /**\n   * Unregisters a disposable object if it has been registered, if not do\n   * nothing.\n   * @param d The disposable to unregister.\n   */\n  public unregister<T extends IDisposable>(d: T): void {\n    const index = this._disposables.indexOf(d);\n    if (index !== -1) {\n      this._disposables.splice(index, 1);\n    }\n  }\n}\n\n/**\n * Dispose of all disposables in an array and set its length to 0.\n */\nexport function disposeArray(disposables: IDisposable[]): void {\n  for (const d of disposables) {\n    d.dispose();\n  }\n  disposables.length = 0;\n}\n\n/**\n * Creates a disposable that will dispose of an array of disposables when disposed.\n */\nexport function getDisposeArrayDisposable(array: IDisposable[]): IDisposable {\n  return { dispose: () => disposeArray(array) };\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport type TypedArray = Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Int8Array | Int16Array | Int32Array | Float32Array | Float64Array;\n\n\n/**\n * polyfill for TypedArray.fill\n * This is needed to support .fill in all safari versions and IE 11.\n */\nexport function fill<T extends TypedArray>(array: T, value: number, start?: number, end?: number): T {\n  // all modern engines that support .fill\n  if (array.fill) {\n    return array.fill(value, start, end) as T;\n  }\n  return fillFallback(array, value, start, end);\n}\n\nexport function fillFallback<T extends TypedArray>(array: T, value: number, start: number = 0, end: number = array.length): T {\n  // safari and IE 11\n  // since IE 11 does not support Array.prototype.fill either\n  // we cannot use the suggested polyfill from MDN\n  // instead we simply fall back to looping\n  if (start >= array.length) {\n    return array;\n  }\n  start = (array.length + start) % array.length;\n  if (end >= array.length) {\n    end = array.length;\n  } else {\n    end = (array.length + end) % array.length;\n  }\n  for (let i = start; i < end; ++i) {\n    array[i] = value;\n  }\n  return array;\n}\n\n/**\n * Concat two typed arrays `a` and `b`.\n * Returns a new typed array.\n */\nexport function concat<T extends TypedArray>(a: T, b: T): T {\n  const result = new (a.constructor as any)(a.length + b.length);\n  result.set(a);\n  result.set(b, a.length);\n  return result;\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IAttributeData, IColorRGB, IExtendedAttrs } from 'common/Types';\nimport { Attributes, FgFlags, BgFlags, UnderlineStyle } from 'common/buffer/Constants';\n\nexport class AttributeData implements IAttributeData {\n  public static toColorRGB(value: number): IColorRGB {\n    return [\n      value >>> Attributes.RED_SHIFT & 255,\n      value >>> Attributes.GREEN_SHIFT & 255,\n      value & 255\n    ];\n  }\n\n  public static fromColorRGB(value: IColorRGB): number {\n    return (value[0] & 255) << Attributes.RED_SHIFT | (value[1] & 255) << Attributes.GREEN_SHIFT | value[2] & 255;\n  }\n\n  public clone(): IAttributeData {\n    const newObj = new AttributeData();\n    newObj.fg = this.fg;\n    newObj.bg = this.bg;\n    newObj.extended = this.extended.clone();\n    return newObj;\n  }\n\n  // data\n  public fg = 0;\n  public bg = 0;\n  public extended = new ExtendedAttrs();\n\n  // flags\n  public isInverse(): number   { return this.fg & FgFlags.INVERSE; }\n  public isBold(): number      { return this.fg & FgFlags.BOLD; }\n  public isUnderline(): number { return this.fg & FgFlags.UNDERLINE; }\n  public isBlink(): number     { return this.fg & FgFlags.BLINK; }\n  public isInvisible(): number { return this.fg & FgFlags.INVISIBLE; }\n  public isItalic(): number    { return this.bg & BgFlags.ITALIC; }\n  public isDim(): number       { return this.bg & BgFlags.DIM; }\n\n  // color modes\n  public getFgColorMode(): number { return this.fg & Attributes.CM_MASK; }\n  public getBgColorMode(): number { return this.bg & Attributes.CM_MASK; }\n  public isFgRGB(): boolean       { return (this.fg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isBgRGB(): boolean       { return (this.bg & Attributes.CM_MASK) === Attributes.CM_RGB; }\n  public isFgPalette(): boolean   { return (this.fg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.fg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isBgPalette(): boolean   { return (this.bg & Attributes.CM_MASK) === Attributes.CM_P16 || (this.bg & Attributes.CM_MASK) === Attributes.CM_P256; }\n  public isFgDefault(): boolean   { return (this.fg & Attributes.CM_MASK) === 0; }\n  public isBgDefault(): boolean   { return (this.bg & Attributes.CM_MASK) === 0; }\n  public isAttributeDefault(): boolean { return this.fg === 0 && this.bg === 0; }\n\n  // colors\n  public getFgColor(): number {\n    switch (this.fg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.fg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.fg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n  public getBgColor(): number {\n    switch (this.bg & Attributes.CM_MASK) {\n      case Attributes.CM_P16:\n      case Attributes.CM_P256:  return this.bg & Attributes.PCOLOR_MASK;\n      case Attributes.CM_RGB:   return this.bg & Attributes.RGB_MASK;\n      default:                  return -1;  // CM_DEFAULT defaults to -1\n    }\n  }\n\n  // extended attrs\n  public hasExtendedAttrs(): number {\n    return this.bg & BgFlags.HAS_EXTENDED;\n  }\n  public updateExtended(): void {\n    if (this.extended.isEmpty()) {\n      this.bg &= ~BgFlags.HAS_EXTENDED;\n    } else {\n      this.bg |= BgFlags.HAS_EXTENDED;\n    }\n  }\n  public getUnderlineColor(): number {\n    if ((this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor) {\n      switch (this.extended.underlineColor & Attributes.CM_MASK) {\n        case Attributes.CM_P16:\n        case Attributes.CM_P256:  return this.extended.underlineColor & Attributes.PCOLOR_MASK;\n        case Attributes.CM_RGB:   return this.extended.underlineColor & Attributes.RGB_MASK;\n        default:                  return this.getFgColor();\n      }\n    }\n    return this.getFgColor();\n  }\n  public getUnderlineColorMode(): number {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? this.extended.underlineColor & Attributes.CM_MASK\n      : this.getFgColorMode();\n  }\n  public isUnderlineColorRGB(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_RGB\n      : this.isFgRGB();\n  }\n  public isUnderlineColorPalette(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P16\n          || (this.extended.underlineColor & Attributes.CM_MASK) === Attributes.CM_P256\n      : this.isFgPalette();\n  }\n  public isUnderlineColorDefault(): boolean {\n    return (this.bg & BgFlags.HAS_EXTENDED) && ~this.extended.underlineColor\n      ? (this.extended.underlineColor & Attributes.CM_MASK) === 0\n      : this.isFgDefault();\n  }\n  public getUnderlineStyle(): UnderlineStyle {\n    return this.fg & FgFlags.UNDERLINE\n      ? (this.bg & BgFlags.HAS_EXTENDED ? this.extended.underlineStyle : UnderlineStyle.SINGLE)\n      : UnderlineStyle.NONE;\n  }\n}\n\n\n/**\n * Extended attributes for a cell.\n * Holds information about different underline styles and color.\n */\nexport class ExtendedAttrs implements IExtendedAttrs {\n  constructor(\n    // underline style, NONE is empty\n    public underlineStyle: UnderlineStyle = UnderlineStyle.NONE,\n    // underline color, -1 is empty (same as FG)\n    public underlineColor: number = -1\n  ) {}\n\n  public clone(): IExtendedAttrs {\n    return new ExtendedAttrs(this.underlineStyle, this.underlineColor);\n  }\n\n  /**\n   * Convenient method to indicate whether the object holds no additional information,\n   * that needs to be persistant in the buffer.\n   */\n  public isEmpty(): boolean {\n    return this.underlineStyle === UnderlineStyle.NONE;\n  }\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { CharData, ICellData, IExtendedAttrs } from 'common/Types';\nimport { stringFromCodePoint } from 'common/input/TextDecoder';\nimport { CHAR_DATA_CHAR_INDEX, CHAR_DATA_WIDTH_INDEX, CHAR_DATA_ATTR_INDEX, Content } from 'common/buffer/Constants';\nimport { AttributeData, ExtendedAttrs } from 'common/buffer/AttributeData';\n\n/**\n * CellData - represents a single Cell in the terminal buffer.\n */\nexport class CellData extends AttributeData implements ICellData {\n  /** Helper to create CellData from CharData. */\n  public static fromCharData(value: CharData): CellData {\n    const obj = new CellData();\n    obj.setFromCharData(value);\n    return obj;\n  }\n  /** Primitives from terminal buffer. */\n  public content = 0;\n  public fg = 0;\n  public bg = 0;\n  public extended: IExtendedAttrs = new ExtendedAttrs();\n  public combinedData = '';\n  /** Whether cell contains a combined string. */\n  public isCombined(): number {\n    return this.content & Content.IS_COMBINED_MASK;\n  }\n  /** Width of the cell. */\n  public getWidth(): number {\n    return this.content >> Content.WIDTH_SHIFT;\n  }\n  /** JS string of the content. */\n  public getChars(): string {\n    if (this.content & Content.IS_COMBINED_MASK) {\n      return this.combinedData;\n    }\n    if (this.content & Content.CODEPOINT_MASK) {\n      return stringFromCodePoint(this.content & Content.CODEPOINT_MASK);\n    }\n    return '';\n  }\n  /**\n   * Codepoint of cell\n   * Note this returns the UTF32 codepoint of single chars,\n   * if content is a combined string it returns the codepoint\n   * of the last char in string to be in line with code in CharData.\n   * */\n  public getCode(): number {\n    return (this.isCombined())\n      ? this.combinedData.charCodeAt(this.combinedData.length - 1)\n      : this.content & Content.CODEPOINT_MASK;\n  }\n  /** Set data from CharData */\n  public setFromCharData(value: CharData): void {\n    this.fg = value[CHAR_DATA_ATTR_INDEX];\n    this.bg = 0;\n    let combined = false;\n    // surrogates and combined strings need special treatment\n    if (value[CHAR_DATA_CHAR_INDEX].length > 2) {\n      combined = true;\n    }\n    else if (value[CHAR_DATA_CHAR_INDEX].length === 2) {\n      const code = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0);\n      // if the 2-char string is a surrogate create single codepoint\n      // everything else is combined\n      if (0xD800 <= code && code <= 0xDBFF) {\n        const second = value[CHAR_DATA_CHAR_INDEX].charCodeAt(1);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          this.content = ((code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n        }\n        else {\n          combined = true;\n        }\n      }\n      else {\n        combined = true;\n      }\n    }\n    else {\n      this.content = value[CHAR_DATA_CHAR_INDEX].charCodeAt(0) | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n    if (combined) {\n      this.combinedData = value[CHAR_DATA_CHAR_INDEX];\n      this.content = Content.IS_COMBINED_MASK | (value[CHAR_DATA_WIDTH_INDEX] << Content.WIDTH_SHIFT);\n    }\n  }\n  /** Get data as CharData. */\n  public getAsCharData(): CharData {\n    return [this.fg, this.getChars(), this.getWidth(), this.getCode()];\n  }\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nexport const DEFAULT_COLOR = 256;\nexport const DEFAULT_ATTR = (0 << 18) | (DEFAULT_COLOR << 9) | (256 << 0);\n\nexport const CHAR_DATA_ATTR_INDEX = 0;\nexport const CHAR_DATA_CHAR_INDEX = 1;\nexport const CHAR_DATA_WIDTH_INDEX = 2;\nexport const CHAR_DATA_CODE_INDEX = 3;\n\n/**\n * Null cell - a real empty cell (containing nothing).\n * Note that code should always be 0 for a null cell as\n * several test condition of the buffer line rely on this.\n */\nexport const NULL_CELL_CHAR = '';\nexport const NULL_CELL_WIDTH = 1;\nexport const NULL_CELL_CODE = 0;\n\n/**\n * Whitespace cell.\n * This is meant as a replacement for empty cells when needed\n * during rendering lines to preserve correct aligment.\n */\nexport const WHITESPACE_CELL_CHAR = ' ';\nexport const WHITESPACE_CELL_WIDTH = 1;\nexport const WHITESPACE_CELL_CODE = 32;\n\n/**\n * Bitmasks for accessing data in `content`.\n */\nexport const enum Content {\n  /**\n   * bit 1..21    codepoint, max allowed in UTF32 is 0x10FFFF (21 bits taken)\n   *              read:   `codepoint = content & Content.codepointMask;`\n   *              write:  `content |= codepoint & Content.codepointMask;`\n   *                      shortcut if precondition `codepoint <= 0x10FFFF` is met:\n   *                      `content |= codepoint;`\n   */\n  CODEPOINT_MASK = 0x1FFFFF,\n\n  /**\n   * bit 22       flag indication whether a cell contains combined content\n   *              read:   `isCombined = content & Content.isCombined;`\n   *              set:    `content |= Content.isCombined;`\n   *              clear:  `content &= ~Content.isCombined;`\n   */\n  IS_COMBINED_MASK = 0x200000,  // 1 << 21\n\n  /**\n   * bit 1..22    mask to check whether a cell contains any string data\n   *              we need to check for codepoint and isCombined bits to see\n   *              whether a cell contains anything\n   *              read:   `isEmpty = !(content & Content.hasContent)`\n   */\n  HAS_CONTENT_MASK = 0x3FFFFF,\n\n  /**\n   * bit 23..24   wcwidth value of cell, takes 2 bits (ranges from 0..2)\n   *              read:   `width = (content & Content.widthMask) >> Content.widthShift;`\n   *                      `hasWidth = content & Content.widthMask;`\n   *                      as long as wcwidth is highest value in `content`:\n   *                      `width = content >> Content.widthShift;`\n   *              write:  `content |= (width << Content.widthShift) & Content.widthMask;`\n   *                      shortcut if precondition `0 <= width <= 3` is met:\n   *                      `content |= width << Content.widthShift;`\n   */\n  WIDTH_MASK = 0xC00000,   // 3 << 22\n  WIDTH_SHIFT = 22\n}\n\nexport const enum Attributes {\n  /**\n   * bit 1..8     blue in RGB, color in P256 and P16\n   */\n  BLUE_MASK = 0xFF,\n  BLUE_SHIFT = 0,\n  PCOLOR_MASK = 0xFF,\n  PCOLOR_SHIFT = 0,\n\n  /**\n   * bit 9..16    green in RGB\n   */\n  GREEN_MASK = 0xFF00,\n  GREEN_SHIFT = 8,\n\n  /**\n   * bit 17..24   red in RGB\n   */\n  RED_MASK = 0xFF0000,\n  RED_SHIFT = 16,\n\n  /**\n   * bit 25..26   color mode: DEFAULT (0) | P16 (1) | P256 (2) | RGB (3)\n   */\n  CM_MASK = 0x3000000,\n  CM_DEFAULT = 0,\n  CM_P16 = 0x1000000,\n  CM_P256 = 0x2000000,\n  CM_RGB = 0x3000000,\n\n  /**\n   * bit 1..24  RGB room\n   */\n  RGB_MASK = 0xFFFFFF\n}\n\nexport const enum FgFlags {\n  /**\n   * bit 27..31 (32th bit unused)\n   */\n  INVERSE = 0x4000000,\n  BOLD = 0x8000000,\n  UNDERLINE = 0x10000000,\n  BLINK = 0x20000000,\n  INVISIBLE = 0x40000000\n}\n\nexport const enum BgFlags {\n  /**\n   * bit 27..32 (upper 3 unused)\n   */\n  ITALIC = 0x4000000,\n  DIM = 0x8000000,\n  HAS_EXTENDED = 0x10000000\n}\n\nexport const enum UnderlineStyle {\n  NONE = 0,\n  SINGLE = 1,\n  DOUBLE = 2,\n  CURLY = 3,\n  DOTTED = 4,\n  DASHED = 5\n}\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\n/**\n * Polyfill - Convert UTF32 codepoint into JS string.\n * Note: The built-in String.fromCodePoint happens to be much slower\n *       due to additional sanity checks. We can avoid them since\n *       we always operate on legal UTF32 (granted by the input decoders)\n *       and use this faster version instead.\n */\nexport function stringFromCodePoint(codePoint: number): string {\n  if (codePoint > 0xFFFF) {\n    codePoint -= 0x10000;\n    return String.fromCharCode((codePoint >> 10) + 0xD800) + String.fromCharCode((codePoint % 0x400) + 0xDC00);\n  }\n  return String.fromCharCode(codePoint);\n}\n\n/**\n * Convert UTF32 char codes into JS string.\n * Basically the same as `stringFromCodePoint` but for multiple codepoints\n * in a loop (which is a lot faster).\n */\nexport function utf32ToString(data: Uint32Array, start: number = 0, end: number = data.length): string {\n  let result = '';\n  for (let i = start; i < end; ++i) {\n    let codepoint = data[i];\n    if (codepoint > 0xFFFF) {\n      // JS strings are encoded as UTF16, thus a non BMP codepoint gets converted into a surrogate pair\n      // conversion rules:\n      //  - subtract 0x10000 from code point, leaving a 20 bit number\n      //  - add high 10 bits to 0xD800  --> first surrogate\n      //  - add low 10 bits to 0xDC00   --> second surrogate\n      codepoint -= 0x10000;\n      result += String.fromCharCode((codepoint >> 10) + 0xD800) + String.fromCharCode((codepoint % 0x400) + 0xDC00);\n    } else {\n      result += String.fromCharCode(codepoint);\n    }\n  }\n  return result;\n}\n\n/**\n * StringToUtf32 - decodes UTF16 sequences into UTF32 codepoints.\n * To keep the decoder in line with JS strings it handles single surrogates as UCS2.\n */\nexport class StringToUtf32 {\n  private _interim: number = 0;\n\n  /**\n   * Clears interim and resets decoder to clean state.\n   */\n  public clear(): void {\n    this._interim = 0;\n  }\n\n  /**\n   * Decode JS string to UTF32 codepoints.\n   * The methods assumes stream input and will store partly transmitted\n   * surrogate pairs and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided input data does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: string, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let startPos = 0;\n\n    // handle leftover surrogate high\n    if (this._interim) {\n      const second = input.charCodeAt(startPos++);\n      if (0xDC00 <= second && second <= 0xDFFF) {\n        target[size++] = (this._interim - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      } else {\n        // illegal codepoint (USC2 handling)\n        target[size++] = this._interim;\n        target[size++] = second;\n      }\n      this._interim = 0;\n    }\n\n    for (let i = startPos; i < length; ++i) {\n      const code = input.charCodeAt(i);\n      // surrogate pair first\n      if (0xD800 <= code && code <= 0xDBFF) {\n        if (++i >= length) {\n          this._interim = code;\n          return size;\n        }\n        const second = input.charCodeAt(i);\n        if (0xDC00 <= second && second <= 0xDFFF) {\n          target[size++] = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n        } else {\n          // illegal codepoint (USC2 handling)\n          target[size++] = code;\n          target[size++] = second;\n        }\n        continue;\n      }\n      if (code === 0xFEFF) {\n        // BOM\n        continue;\n      }\n      target[size++] = code;\n    }\n    return size;\n  }\n}\n\n/**\n * Utf8Decoder - decodes UTF8 byte sequences into UTF32 codepoints.\n */\nexport class Utf8ToUtf32 {\n  public interim: Uint8Array = new Uint8Array(3);\n\n  /**\n   * Clears interim bytes and resets decoder to clean state.\n   */\n  public clear(): void {\n    this.interim.fill(0);\n  }\n\n  /**\n   * Decodes UTF8 byte sequences in `input` to UTF32 codepoints in `target`.\n   * The methods assumes stream input and will store partly transmitted bytes\n   * and decode them with the next data chunk.\n   * Note: The method does no bound checks for target, therefore make sure\n   * the provided data chunk does not exceed the size of `target`.\n   * Returns the number of written codepoints in `target`.\n   */\n  public decode(input: Uint8Array, target: Uint32Array): number {\n    const length = input.length;\n\n    if (!length) {\n      return 0;\n    }\n\n    let size = 0;\n    let byte1: number;\n    let byte2: number;\n    let byte3: number;\n    let byte4: number;\n    let codepoint = 0;\n    let startPos = 0;\n\n    // handle leftover bytes\n    if (this.interim[0]) {\n      let discardInterim = false;\n      let cp = this.interim[0];\n      cp &= ((((cp & 0xE0) === 0xC0)) ? 0x1F : (((cp & 0xF0) === 0xE0)) ? 0x0F : 0x07);\n      let pos = 0;\n      let tmp: number;\n      while ((tmp = this.interim[++pos] & 0x3F) && pos < 4) {\n        cp <<= 6;\n        cp |= tmp;\n      }\n      // missing bytes - read ahead from input\n      const type = (((this.interim[0] & 0xE0) === 0xC0)) ? 2 : (((this.interim[0] & 0xF0) === 0xE0)) ? 3 : 4;\n      const missing = type - pos;\n      while (startPos < missing) {\n        if (startPos >= length) {\n          return 0;\n        }\n        tmp = input[startPos++];\n        if ((tmp & 0xC0) !== 0x80) {\n          // wrong continuation, discard interim bytes completely\n          startPos--;\n          discardInterim = true;\n          break;\n        } else {\n          // need to save so we can continue short inputs in next call\n          this.interim[pos++] = tmp;\n          cp <<= 6;\n          cp |= tmp & 0x3F;\n        }\n      }\n      if (!discardInterim) {\n        // final test is type dependent\n        if (type === 2) {\n          if (cp < 0x80) {\n            // wrong starter byte\n            startPos--;\n          } else {\n            target[size++] = cp;\n          }\n        } else if (type === 3) {\n          if (cp < 0x0800 || (cp >= 0xD800 && cp <= 0xDFFF) || cp === 0xFEFF) {\n            // illegal codepoint or BOM\n          } else {\n            target[size++] = cp;\n          }\n        } else {\n          if (cp < 0x010000 || cp > 0x10FFFF) {\n            // illegal codepoint\n          } else {\n            target[size++] = cp;\n          }\n        }\n      }\n      this.interim.fill(0);\n    }\n\n    // loop through input\n    const fourStop = length - 4;\n    let i = startPos;\n    while (i < length) {\n      /**\n       * ASCII shortcut with loop unrolled to 4 consecutive ASCII chars.\n       * This is a compromise between speed gain for ASCII\n       * and penalty for non ASCII:\n       * For best ASCII performance the char should be stored directly into target,\n       * but even a single attempt to write to target and compare afterwards\n       * penalizes non ASCII really bad (-50%), thus we load the char into byteX first,\n       * which reduces ASCII performance by ~15%.\n       * This trial for ASCII reduces non ASCII performance by ~10% which seems acceptible\n       * compared to the gains.\n       * Note that this optimization only takes place for 4 consecutive ASCII chars,\n       * for any shorter it bails out. Worst case - all 4 bytes being read but\n       * thrown away due to the last being a non ASCII char (-10% performance).\n       */\n      while (i < fourStop\n        && !((byte1 = input[i]) & 0x80)\n        && !((byte2 = input[i + 1]) & 0x80)\n        && !((byte3 = input[i + 2]) & 0x80)\n        && !((byte4 = input[i + 3]) & 0x80))\n      {\n        target[size++] = byte1;\n        target[size++] = byte2;\n        target[size++] = byte3;\n        target[size++] = byte4;\n        i += 4;\n      }\n\n      // reread byte1\n      byte1 = input[i++];\n\n      // 1 byte\n      if (byte1 < 0x80) {\n        target[size++] = byte1;\n\n        // 2 bytes\n      } else if ((byte1 & 0xE0) === 0xC0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x1F) << 6 | (byte2 & 0x3F);\n        if (codepoint < 0x80) {\n          // wrong starter byte\n          i--;\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 3 bytes\n      } else if ((byte1 & 0xF0) === 0xE0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x0F) << 12 | (byte2 & 0x3F) << 6 | (byte3 & 0x3F);\n        if (codepoint < 0x0800 || (codepoint >= 0xD800 && codepoint <= 0xDFFF) || codepoint === 0xFEFF) {\n          // illegal codepoint or BOM, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n\n        // 4 bytes\n      } else if ((byte1 & 0xF8) === 0xF0) {\n        if (i >= length) {\n          this.interim[0] = byte1;\n          return size;\n        }\n        byte2 = input[i++];\n        if ((byte2 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          return size;\n        }\n        byte3 = input[i++];\n        if ((byte3 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        if (i >= length) {\n          this.interim[0] = byte1;\n          this.interim[1] = byte2;\n          this.interim[2] = byte3;\n          return size;\n        }\n        byte4 = input[i++];\n        if ((byte4 & 0xC0) !== 0x80) {\n          // wrong continuation\n          i--;\n          continue;\n        }\n        codepoint = (byte1 & 0x07) << 18 | (byte2 & 0x3F) << 12 | (byte3 & 0x3F) << 6 | (byte4 & 0x3F);\n        if (codepoint < 0x010000 || codepoint > 0x10FFFF) {\n          // illegal codepoint, no i-- here\n          continue;\n        }\n        target[size++] = codepoint;\n      } else {\n        // illegal byte, just skip\n      }\n    }\n    return size;\n  }\n}\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, ITerminalAddon, IEvent } from 'xterm';\nimport { WebglRenderer } from './WebglRenderer';\nimport { ICharacterJoinerService, IRenderService } from 'browser/services/Services';\nimport { IColorSet } from 'browser/Types';\nimport { EventEmitter } from 'common/EventEmitter';\n\nexport class WebglAddon implements ITerminalAddon {\n  private _terminal?: Terminal;\n  private _renderer?: WebglRenderer;\n  private _onContextLoss = new EventEmitter<void>();\n  public get onContextLoss(): IEvent<void> { return this._onContextLoss.event; }\n\n  constructor(\n    private _preserveDrawingBuffer?: boolean\n  ) {}\n\n  public activate(terminal: Terminal): void {\n    if (!terminal.element) {\n      throw new Error('Cannot activate WebglAddon before Terminal.open');\n    }\n    this._terminal = terminal;\n    const renderService: IRenderService = (<any>terminal)._core._renderService;\n    const characterJoinerService: ICharacterJoinerService = (<any>terminal)._core._characterJoinerService;\n    const colors: IColorSet = (<any>terminal)._core._colorManager.colors;\n    this._renderer = new WebglRenderer(terminal, colors, characterJoinerService, this._preserveDrawingBuffer);\n    this._renderer.onContextLoss(() => this._onContextLoss.fire());\n    renderService.setRenderer(this._renderer);\n  }\n\n  public dispose(): void {\n    if (!this._terminal) {\n      throw new Error('Cannot dispose WebglAddon because it is activated');\n    }\n    const renderService: IRenderService = (this._terminal as any)._core._renderService;\n    renderService.setRenderer((this._terminal as any)._core._createRenderer());\n    renderService.onResize(this._terminal.cols, this._terminal.rows);\n    this._renderer = undefined;\n  }\n\n  public get textureAtlas(): HTMLCanvasElement | undefined {\n    return this._renderer?.textureAtlas;\n  }\n\n  public clearTextureAtlas(): void {\n    this._renderer?.clearCharAtlas();\n  }\n}\n"],"names":["root","factory","self","__webpack_require__","moduleId","cachedModule","__webpack_module_cache__","exports","module","__webpack_modules__","call","r","i","o","n","s","a","l","INDICES_PER_CELL","BYTES_PER_CELL","Float32Array","BYTES_PER_ELEMENT","_","t2","_terminal","_colors","_gl","_dimensions","_activeBuffer","this","_vertices","count","attributes","attributesBuffers","selectionAttributes","gl","program","throwIfFalsy","createProgram","_program","_projectionLocation","getUniformLocation","_resolutionLocation","_textureLocation","_vertexArrayObject","createVertexArray","bindVertexArray","unitQuadVertices","unitQuadVerticesBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","unitQuadElementIndices","Uint8Array","elementIndicesBuffer","ELEMENT_ARRAY_BUFFER","_attributesBuffer","vertexAttribDivisor","_atlasTexture","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","enable","BLEND","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","onResize","prototype","beginFrame","_atlas","updateCell","x","y","code","bg","fg","chars","_updateCell","array","rasterizedGlyph","cols","NULL_CELL_CODE","WHITESPACE_CELL_CODE","length","getRasterizedGlyphCombinedChar","getRasterizedGlyph","offset","scaledCharLeft","scaledCharTop","size","scaledCanvasWidth","scaledCanvasHeight","texturePositionClipSpace","sizeClipSpace","fill","updateSelection","model","terminal","slice","selectionOpaque","rgba","selection","columnSelectMode","startCol","width","endCol","height","viewportCappedEndRow","viewportCappedStartRow","_updateSelectionRange","startRowEndCol","viewportStartRow","middleRowsCount","Math","max","viewportEndRow","line","row","buffer","active","viewportY","RENDER_MODEL_INDICIES_PER_CELL","cells","RENDER_MODEL_FG_OFFSET","workCell","AttributeData","RENDER_MODEL_BG_OFFSET","getBgColorMode","c","_getColorFromAnsiIndex","getBgColor","arr","toColorRGB","c2","background","COMBINED_CHAR_BIT_MASK","getLine","getCell","getChars","idx","ansi","Error","viewport","canvas","newCount","rows","r1","setColors","render","renderModel","isSelectionVisible","useProgram","activeBuffer","bufferLength","lineLengths","si","sub","subarray","set","STREAM_DRAW","hasCanvasChanged","uniform1i","activeTexture","TEXTURE0","cacheCanvas","generateMipmap","uniformMatrix4fv","PROJECTION_MATRIX","uniform2f","drawElementsInstanced","TRIANGLES","setAtlas","atlas","setDimensions","dimensions","e","GlyphRenderer","r2","i2","o3","n3","BYTES_PER_RECTANGLE","a2","_updateCachedColors","DYNAMIC_DRAW","_updateViewportRectangle","_bgFloat","_colorToFloat32Array","_selectionFloat","_addRectangleFloat","scaledCellWidth","scaledCellHeight","hasSelection","INDICES_PER_RECTANGLE","updateBackgrounds","vertices","rectangleCount","currentStartX","currentBg","currentFg","currentInverse","modelIndex","inverse","_updateRectangle","startX","endX","foreground","expandFloat32Array","_addRectangle","x1","y1","g","b","color","RectangleRenderer","r4","o4","Uint32Array","resize","indexCount","clear","clearSelection","RenderModel","sliceFallback","start","end","result","constructor","min","n5","s6","a5","l5","h3","c3","_3","d","u","f","p","v","e1","_characterJoinerService","preserveDrawingBuffer","l6","_model","_workCell","CellData","_onRequestRedraw","EventEmitter","_onContextLoss","_core","_renderLayers","LinkRenderLayer","screenElement","CursorRenderLayer","scaledCharWidth","scaledCharHeight","canvasWidth","canvasHeight","actualCellWidth","actualCellHeight","_devicePixelRatio","window","devicePixelRatio","_updateDimensions","_canvas","document","createElement","getContext","contextAttributes","antialias","depth","o6","register","addDisposableDomListener","fire","appendChild","_rectangleRenderer","_glyphRenderer","onCharSizeChanged","_isAttached","body","contains","o5","Object","defineProperty","event","dispose","e2","i4","removeChild","t3","_charAtlas","colors","reset","_refreshCharAtlas","onDevicePixelRatioChange","r7","style","onBlur","onFocus","onSelectionChanged","_updateSelectionModel","onCursorMove","onOptionsChanged","acquireCharAtlas","warmUp","clearCharAtlas","t4","clearTexture","_updateModel","registerCharacterJoiner","handler","deregisterCharacterJoiner","joinerId","renderRows","_charSizeService","onGridChanged","undefined","cell","ydisp","lines","get","joinedRanges","getJoinedCharacters","loadCell","isJoined","lastCharX","range","shift","JoinedCellData","translateToString","getCode","j","NULL_CELL_CHAR","floor","ceil","getOption","round","Disposable","WebglRenderer","C","firstCell","content","combinedData","_width","isCombined","getWidth","setFromCharData","value","getAsCharData","createShader","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","error","getShaderInfoLog","deleteShader","vertexSource","fragmentSource","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","newArray","r5","charAtlasCache","newConfig","generateConfig","ownedByIndex","entry","ownedBy","indexOf","configEquals","config","splice","push","newEntry","WebglCharAtlas","removeTerminalFromCache","index","NULL_COLOR","css","clonedColors","cursor","cursorAccent","selectionTransparent","contrastCache","fontFamily","fontSize","fontWeight","fontWeightBold","allowTransparency","drawBoldTextInBrightColors","minimumContrastRatio","is256Color","colorCode","toPaddedHex","toString","i5","n7","TEXTURE_WIDTH","TEXTURE_HEIGHT","TRANSPARENT_COLOR","NULL_RASTERIZED_GLYPH","texturePosition","u2","_config","_didWarmUp","_cacheMap","_cacheMapCombined","_currentRowY","_currentRowX","_currentRowHeight","_workBoundingBox","top","left","bottom","right","_workAttributeData","_cacheCtx","alpha","_tmpCanvas","TMP_CANVAS_GLYPH_PADDING","_tmpCtx","parentElement","_doWarmUp","_drawToCache","DEFAULT_COLOR","TEXTURE_CAPACITY","clearRect","rasterizedGlyphSet","rasterizedGlyphSetBg","_getBackgroundColor","bgColorMode","bgColor","_getForegroundCss","fgColorMode","fgColor","bold","minimumContrastCss","_getMinimumContrastCss","channels","toCss","d1","substr","_resolveBackgroundRgba","_resolveForegroundRgba","adjustedColor","getCss","bgRgba","fgRgba","ensureContrastRatio","setCss","codeOrChars","String","fromCharCode","allowedWidth","save","isInvisible","isBold","isInverse","dim","isDim","italic","isItalic","getFgColor","getFgColorMode","temp","temp2","backgroundColor","globalCompositeOperation","fillStyle","fillRect","font","fontStyle","textBaseline","globalAlpha","DIM_OPACITY","isPowerlineGlyph","charCodeAt","padding","fillText","restore","imageData","getImageData","isEmpty","data","_findGlyphBoundingBox","clippedImageData","_clipImageData","putImageData","boundingBox","restrictedGlyph","found","alphaOffset","clippedData","Uint8ClampedArray","oldOffset","newOffset","ImageData","r9","o7","n8","_container","id","zIndex","_alpha","_scaledCharWidth","_scaledCharHeight","_scaledCellWidth","_scaledCellHeight","_scaledCharLeft","_scaledCharTop","classList","add","_initCanvas","_ctx","_clearAll","startRow","endRow","colorSet","_setTransparency","oldCanvas","cloneNode","replaceChild","_fillCells","_fillBottomLineAtCells","_fillLeftLineAtCell","_strokeRectAtCell","lineWidth","strokeRect","_clearCells","_fillCharTrueColor","_getFont","_clipRow","beginPath","rect","clip","BaseRenderLayer","isTerminalFocused","activeElement","textarea","hasFocus","n9","s8","BLINK_INTERVAL","l8","container","_onRequestRefreshRowsEvent","n10","_cell","_state","isFocused","_cursorRenderers","bar","_renderBarCursor","bind","block","_renderBlockCursor","underline","_renderUnderlineCursor","o8","_clearCursor","_cursorBlinkStateManager","pause","cursorY","resume","i7","CursorBlinkStateManager","_render","restartBlinkAnimation","isPaused","triggeredByAnimationFrame","_coreService","isCursorInitialized","isCursorHidden","baseY","viewportRelativeCursorY","cursorX","cursorStyle","_renderBlurCursor","isCursorVisible","strokeStyle","h7","_renderCallback","_restartInterval","_blinkStartTimeout","_blinkInterval","clearInterval","clearTimeout","_animationFrame","cancelAnimationFrame","_animationTimeRestarted","Date","now","requestAnimationFrame","timeToStart","a8","setTimeout","time","setInterval","n11","linkifier","onShowLinkUnderline","_onShowLinkUnderline","onHideLinkUnderline","_onHideLinkUnderline","linkifier2","_clearCurrentLink","middleRowCount","y2","x2","INVERTED_DEFAULT_COLOR","contrastRatio","l1","l2","r10","rgb","toRgba","blend","fgG","fgB","bgR","bgG","bgB","isOpaque","ratio","toColor","opaque","rgbaColor","r12","toChannels","opacity","o10","parseInt","relativeLuminance2","rs","gs","bs","pow","relativeLuminance","t7","e3","reduceLuminance","fgR","cr","increaseLuminance","bgL","fgL","node","options","addEventListener","disposed","removeEventListener","CHAR_ATLAS_CELL_SPACING","i8","_listeners","_disposed","_event","listener","arg1","arg2","queue","forwardEvent","from","to","disposeArray","disposables","i10","i9","_disposables","_isDisposed","unregister","getDisposeArrayDisposable","fillFallback","concat","extended","ExtendedAttrs","fromColorRGB","clone","newObj","isUnderline","isBlink","isFgRGB","isBgRGB","isFgPalette","isBgPalette","isFgDefault","isBgDefault","isAttributeDefault","hasExtendedAttrs","updateExtended","getUnderlineColor","underlineColor","getUnderlineColorMode","isUnderlineColorRGB","isUnderlineColorPalette","isUnderlineColorDefault","getUnderlineStyle","underlineStyle","i11","e4","apply","arguments","fromCharData","obj","stringFromCodePoint","CHAR_DATA_ATTR_INDEX","combined","CHAR_DATA_CHAR_INDEX","second","CHAR_DATA_WIDTH_INDEX","DEFAULT_ATTR","CHAR_DATA_CODE_INDEX","NULL_CELL_WIDTH","WHITESPACE_CELL_CHAR","WHITESPACE_CELL_WIDTH","codePoint","utf32ToString","codepoint","_interim","decode","input","target","startPos","StringToUtf32","r13","interim","byte1","byte2","byte3","byte4","discardInterim","cp","pos","tmp","missing","fourStop","Utf8ToUtf32","i13","n12","_preserveDrawingBuffer","activate","i14","element","renderService","_renderService","_renderer","_colorManager","characterJoinerService","onContextLoss","setRenderer","_createRenderer","textureAtlas","clearTextureAtlas","t1","WebglAddon","r15","define","amd"],"version":3,"file":"xterm-addon-webgl.080d16c5.js.map"}